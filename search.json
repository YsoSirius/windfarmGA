[{"path":"https://YsoSirius.github.io/windfarmGA/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sebastian Gatscha. Author, maintainer, copyright holder.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Gatscha S (2025). windfarmGA: Genetic Algorithm Wind Farm Layout Optimization. R package version 4.0.0.9000, https://ysosirius.github.io/windfarmGA/index.html.","code":"@Manual{,   title = {windfarmGA: Genetic Algorithm for Wind Farm Layout Optimization},   author = {Sebastian Gatscha},   year = {2025},   note = {R package version 4.0.0.9000},   url = {https://ysosirius.github.io/windfarmGA/index.html}, }"},{"path":"https://YsoSirius.github.io/windfarmGA/index.html","id":"windfarmga","dir":"","previous_headings":"","what":"Genetic Algorithm for Wind Farm Layout Optimization","title":"Genetic Algorithm for Wind Farm Layout Optimization","text":"Genetic algorithm optimize layout windfarms. package hosted CRAN","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Genetic Algorithm for Wind Farm Layout Optimization","text":"latest version can installed GitHub : CRAN-version :","code":"devtools::install_github(\"YsoSirius/windfarmGA\") install.packages(\"windfarmGA\")"},{"path":"https://YsoSirius.github.io/windfarmGA/index.html","id":"description","dir":"","previous_headings":"","what":"Description","title":"Genetic Algorithm for Wind Farm Layout Optimization","text":"genetic algorithm designed optimize wind farms shape. requires predefined number turbines, uniform rotor radius average wind speed per wind direction. can include terrain effect model, requires elevation raster surface roughness raster. elevation data used find mountains valleys adjust wind speeds accordingly ‘wind multipliers’ determine air densities rotor heights. surface roughness raster additional elevation roughness value used re-evaluate surface roughness individually determine wake-decay constant turbine. start optimization use function genetic_algorithm.  Since version 1.1, hexagonal grid cells possible, center points possible locations wind turbines. Furthermore, rasters can included, contain information Weibull parameters. Austria data already included package.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/index.html","id":"create-an-input-polygon","dir":"","previous_headings":"","what":"Create an input Polygon","title":"Genetic Algorithm for Wind Farm Layout Optimization","text":"Input Polygon source create random Polygon","code":"library(sf) dsn <- \"Path to the Shapefile\" layer <- \"Name of the Shapefile\" Polygon1 <- sf::st_read(dsn = dsn, layer = layer) plot(Polygon1, col = \"blue\") library(sf) Polygon1 <- sf::st_as_sf(sf::st_sfc(   sf::st_polygon(list(cbind(     c(0, 0, 2000, 2000, 0),     c(0, 2000, 2000, 0, 0)))),   crs = 3035 )) plot(Polygon1, col = \"blue\", axes = TRUE)"},{"path":"https://YsoSirius.github.io/windfarmGA/index.html","id":"create-random-wind-data","dir":"","previous_headings":"","what":"Create random Wind data","title":"Genetic Algorithm for Wind Farm Layout Optimization","text":"Exemplary input Wind data uniform wind speed single wind direction Exemplary input Wind data random wind speeds random wind directions","code":"wind_df <- data.frame(ws = c(12, 12), wd = c(0, 0), probab = c(25, 25)) windrosePlot <- plot_windrose(data = wind_df, spd = wind_df$ws,                               dir = wind_df$wd, dirres=10, spdmax = 20) wind_df <- data.frame(ws = sample(1:25, 10), wd = sample(1:260, 10))) windrosePlot <- plot_windrose(data = wind_df, spd = wind_df$ws,                               dir = wind_df$wd)"},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/index.html","id":"rectangular-grid-cells","dir":"","previous_headings":"Grid Spacing","what":"Rectangular Grid Cells","title":"Genetic Algorithm for Wind Farm Layout Optimization","text":"Verify grid spacing appropriate. Adapt following input variables necessary: - Rotor: rotor radius meters. - fcrR: grid spacing factor, least 2, single grid covers least whole rotor diameter. - prop: proportionality factor used grid calculation. determines minimum percentage grid cell must cover area. Make sure Polygon projected meters.","code":"Rotor <- 20 fcrR <- 9 Grid <- grid_area(Polygon1, size = (Rotor * fcrR), prop = 1, plotGrid = TRUE) str(Grid)"},{"path":"https://YsoSirius.github.io/windfarmGA/index.html","id":"hexagonal-grid-cells","dir":"","previous_headings":"Grid Spacing","what":"Hexagonal Grid Cells","title":"Genetic Algorithm for Wind Farm Layout Optimization","text":"","code":"Rotor <- 20 fcrR <- 9 HexGrid <- hexa_area(Polygon1, size = (Rotor * fcrR), plotGrid = TRUE) str(HexGrid)"},{"path":"https://YsoSirius.github.io/windfarmGA/index.html","id":"terrain-effect-model","dir":"","previous_headings":"","what":"Terrain Effect Model","title":"Genetic Algorithm for Wind Farm Layout Optimization","text":"input variable topograp functions windfarmGA genetic_algorithm TRUE, genetic algorithm take terrain effects account. purpose elevation model Corine Land Cover raster downloaded automatically, can also given manually. ( Download CLC raster ). want include Land Cover Raster, must assign Raster Image path input variable sourceCCL. algorithm uses adapted version Raster legend (“clc_legend.csv”), stored package subdirectory (/extdata). use values land cover roughness lengths, insert column named Rauhigkeit_z .csv file. Assign surface roughness length land cover types. sure rows filled numeric values save .csv file “;” delimiter. Assign .csv file path input variable sourceCCLRoughness.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/index.html","id":"start-an-optimization","dir":"","previous_headings":"","what":"Start an Optimization","title":"Genetic Algorithm for Wind Farm Layout Optimization","text":"optimization can initiated function genetic_algorithm without terrain effects terrain effects","code":"result <- genetic_algorithm(   Polygon1 = Polygon1, n = 12, Rotor = 20, fcrR = 9, iteration = 10,   vdirspe = wind_df, crossPart1 = \"EQU\", selstate = \"FIX\", mutr = 0.8,   Proportionality = 1, SurfaceRoughness = 0.3, topograp = FALSE,   elitism =TRUE, nelit = 7, trimForce = TRUE,   referenceHeight = 50, RotorHeight = 100   ) sourceCCL <- \"Source of the CCL raster (TIF)\" sourceCCLRoughness <- \"Source of the Adaped CCL legend (CSV)\"  result <- genetic_algorithm(   Polygon1 = Polygon1, n = 12, Rotor = 20, fcrR = 9, iteration = 10,   vdirspe = wind_df, crossPart1 = \"EQU\", selstate = \"FIX\", mutr = 0.8,   Proportionality = 1, SurfaceRoughness = 0.3, topograp = TRUE,   elitism = TRUE, nelit = 7, trimForce = TRUE,   referenceHeight = 50, RotorHeight = 100, sourceCCL = sourceCCL,   sourceCCLRoughness = sourceCCLRoughness ) ## Run an optimization with your own Weibull parameter rasters. The shape and scale  ## parameter rasters of the weibull distributions must be added to a list, with the first ## list item being the shape parameter (k) and the second list item being the scale ## parameter (a). Adapt the paths to your raster data and run an optimization. kraster <- \"/..pathto../k_param_raster.tif\" araster <- \"/..pathto../a_param_raster.tif\" weibullrasters <- list(raster(kraster), raster(araster))  result_weibull <- genetic_algorithm(   Polygon1 = Polygon1, GridMethod =\"h\", n=12,   fcrR=5, iteration=10, vdirspe = wind_df, crossPart1 = \"EQU\",   selstate=\"FIX\", mutr=0.8, Proportionality = 1, Rotor=30,   SurfaceRoughness = 0.3, topograp = FALSE,   elitism=TRUE, nelit = 7, trimForce = TRUE,   referenceHeight = 50,RotorHeight = 100,   weibull = TRUE, weibullsrc = weibullrasters) plot_windfarmGA(result = result_weibull, Polygon1 = Polygon1)"},{"path":"https://YsoSirius.github.io/windfarmGA/index.html","id":"plot-the-results-on-a-leaflet-map","dir":"","previous_headings":"Start an Optimization","what":"Plot the Results on a Leaflet Map","title":"Genetic Algorithm for Wind Farm Layout Optimization","text":"","code":"## Plot the best wind farm on a leaflet map (ordered by energy values) plot_leaflet(result = resulthex, Polygon1, which = 1)  ## Plot the last wind farm (ordered by chronology). plot_leaflet(result = resulthex, Polygon1, orderitems = FALSE, which = 1)"},{"path":"https://YsoSirius.github.io/windfarmGA/index.html","id":"plotting-methods-of-the-genetic-algorithm","dir":"","previous_headings":"","what":"Plotting Methods of the Genetic Algorithm","title":"Genetic Algorithm for Wind Farm Layout Optimization","text":"Several plotting functions available: full documentation genetic algorithm given master thesis.","code":"- plot_windfarmGA(result, Polygon1)  - plot_result(result, Polygon1, best = 1)  - plot_evolution(result, ask = TRUE, spar = 0.1)  - plot_development(result)  - plot_parkfitness(result, spar = 0.1)  - plot_fitness_evolution(result)  - plot_cloud(result, pl = TRUE)  - plot_heatmap(result = result, si = 5)  - plot_leaflet(result = result, Polygon1 = Polygon1, which = 1)"},{"path":"https://YsoSirius.github.io/windfarmGA/index.html","id":"shiny-windfarm-optimization","dir":"","previous_headings":"","what":"Shiny Windfarm Optimization","title":"Genetic Algorithm for Wind Farm Layout Optimization","text":"also made Shiny App Genetic Algorithm. Unfortunately, optimization takes quite time app currently hosted shinyapps.io public license, 1 R-worker hand. 1 optimization can run time.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/index.html","id":"full-optimization-example","dir":"","previous_headings":"","what":"Full Optimization example:","title":"Genetic Algorithm for Wind Farm Layout Optimization","text":"","code":"library(sf) library(windfarmGA)  Polygon1 <- sf::st_as_sf(sf::st_sfc(   sf::st_polygon(list(cbind(     c(4651704, 4651704, 4654475, 4654475, 4651704),     c(2692925, 2694746, 2694746, 2692925, 2692925)))),    crs = 3035 )) plot(Polygon1, col = \"blue\", axes = TRUE)  wind_df <- data.frame(ws = 12, wd = 0) windrosePlot <- plot_windrose(data = wind_df, spd = wind_df$ws,                              dir = wind_df$wd, dirres = 10, spdmax = 20) Rotor <- 20 fcrR <- 9 Grid <- grid_area(shape = Polygon1, size = (Rotor*fcrR), prop = 1, plotGrid = TRUE)  result <- genetic_algorithm(Polygon1 = sp_polygon,                              n = 20,                             Rotor = Rotor, fcrR = fcrR,                              iteration = 50,                              vdirspe = wind_df,                             referenceHeight = 50, RotorHeight = 100)  # The following function will execute all plotting function further below: plot_windfarmGA(result, Polygon1, whichPl = \"all\", best = 1, plotEn = 1)  # The plotting functions can also be called individually: plot_result(result, Polygon1, best = 1, plotEn = 1, topographie = FALSE) plot_evolution(result, ask = TRUE, spar = 0.1) plot_parkfitness(result, spar = 0.1) plot_fitness_evolution(result) plot_cloud(result, pl = TRUE) plot_heatmap(result = result, si = 5) plot_leaflet(result = result, Polygon1 = Polygon1, which = 1)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/barometric_height.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates Air Density, Air Pressure and Temperature according to the Barometric Height Formula — barometric_height","title":"Calculates Air Density, Air Pressure and Temperature according to the Barometric Height Formula — barometric_height","text":"Calculates air density, temperature air pressure respective certain heights according International standard atmosphere barometric height formula.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/barometric_height.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates Air Density, Air Pressure and Temperature according to the Barometric Height Formula — barometric_height","text":"","code":"barometric_height(data, height, po = 101325, ro = 1.225)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/barometric_height.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates Air Density, Air Pressure and Temperature according to the Barometric Height Formula — barometric_height","text":"data data.frame containing height values height Column name height values po Standardized air pressure sea level (101325 Pa) ro Standardized air density sea level (1,225 kg per m3)","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/barometric_height.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates Air Density, Air Pressure and Temperature according to the Barometric Height Formula — barometric_height","text":"Returns data.frame height values corresponding air pressures, air densities temperatures Kelvin Celsius.","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/barometric_height.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates Air Density, Air Pressure and Temperature according to the Barometric Height Formula — barometric_height","text":"","code":"data <- matrix(seq(0, 5000, 500)) barometric_height(data) #>    Height        ph        rh  tempK  tempC #> 1       0 101325.00 1.2250000 288.15  15.00 #> 2     500  95176.51 1.1506659 284.90  11.75 #> 3    1000  89401.12 1.0808425 281.65   8.50 #> 4    1500  83976.18 1.0152560 278.40   5.25 #> 5    2000  78880.43 0.9536494 275.15   2.00 #> 6    2500  74093.90 0.8957811 271.90  -1.25 #> 7    3000  69597.81 0.8414244 268.65  -4.50 #> 8    3500  65374.56 0.7903660 265.40  -7.75 #> 9    4000  61407.57 0.7424059 262.15 -11.00 #> 10   4500  57681.31 0.6973561 258.90 -14.25 #> 11   5000  54181.16 0.6550399 255.65 -17.50 plot.ts(barometric_height(data))"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/big_shape.html","id":null,"dir":"Reference","previous_headings":"","what":"A POLYGON with an area of ~70 km2 — big_shape","title":"A POLYGON with an area of ~70 km2 — big_shape","text":"POLYGON area ~70 km2","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/big_shape.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A POLYGON with an area of ~70 km2 — big_shape","text":"","code":"big_shape"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/big_shape.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A POLYGON with an area of ~70 km2 — big_shape","text":"object class sf (inherits data.frame) 1 rows 1 columns.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/calculate_energy.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Energy Outputs of Individuals — calculate_energy","title":"Calculate Energy Outputs of Individuals — calculate_energy","text":"Calculate energy output efficiency rates individual current population given wind directions speeds. terrain effect model activated, main calculations model effects done function.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/calculate_energy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Energy Outputs of Individuals — calculate_energy","text":"","code":"calculate_energy(   sel,   referenceHeight,   RotorHeight,   SurfaceRoughness,   wnkl,   distanz,   polygon1,   RotorR,   dirSpeed,   srtm_crop,   topograp,   cclRaster,   weibull,   plotit = FALSE )"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/calculate_energy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Energy Outputs of Individuals — calculate_energy","text":"sel matrix individual current population referenceHeight height incoming wind speeds measured. Default RotorHeight RotorHeight height turbine hub SurfaceRoughness surface roughness length meters. terrain effect model, surface roughness calculated every grid cell using elevation land cover data. Default 0.3 wnkl angle wake influences considered negligible distanz distance wake effects considered eliminated polygon1 considered area Simple Feature Polygon RotorR desired rotor radius meter dirSpeed wind speed direction data.frame srtm_crop first element terrain_model resulting list topograp Boolean value, indicates terrain effect model enabled . Default FALSE cclRaster second element terrain_model resulting list weibull boolean value specifies whether take Weibull parameters account. TRUE, wind speed values vdirspe ignored. algorithm calculate mean wind speed every wind turbine according Weibull parameters. Default FALSE plotit TRUE, process plotted. Default FALSE","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/calculate_energy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Energy Outputs of Individuals — calculate_energy","text":"Returns list individual current generation resulting wake effects, energy outputs, efficiency rates every wind direction. length list corresponds number different wind directions.","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/calculate_energy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Energy Outputs of Individuals — calculate_energy","text":"","code":"# \\donttest{ ## Create a random Polygon library(sf) #> Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE Polygon1 <- sf::st_as_sf(sf::st_sfc(   sf::st_polygon(list(cbind(     c(4498482, 4498482, 4499991, 4499991, 4498482),     c(2668272, 2669343, 2669343, 2668272, 2668272)   ))),   crs = 3035 ))  ## Create a uniform and unidirectional wind data.frame and plot the ## resulting wind rose data.in <- data.frame(ws = 12, wd = 0) windrosePlot <- plot_windrose(   data = data.in, spd = data.in$ws,   dir = data.in$wd, dirres = 10, spdmax = 20 )   ## Assign the rotor radius and a factor of the radius for grid spacing. Rotor <- 50 fcrR <- 3 resGrid <- grid_area(   shape = Polygon1, size = Rotor * fcrR, prop = 1,   plotGrid = TRUE )   ## Assign the indexed data frame to new variable. Element 2 of the list ## is the grid, saved as Simple Feature Polygons. resGrid1 <- resGrid[[1]]  ## Create an initial population with the indexed Grid, 15 turbines and ## 100 individuals. initpop <- init_population(Grid = resGrid1, n = 15, nStart = 100)  ## Calculate the expected energy output of the first individual of the ## population. par(mfrow = c(1, 2)) plot(Polygon1) points(initpop[[1]][, \"X\"], initpop[[1]][, \"Y\"], pch = 20, cex = 2) plot(resGrid[[2]], add = TRUE)  resCalcEn <- calculate_energy(   sel = initpop[[1]], referenceHeight = 50,   RotorHeight = 50, SurfaceRoughness = 0.14, wnkl = 20,   distanz = 100000, dirSpeed = data.in,   RotorR = 50, polygon1 = Polygon1, topograp = FALSE,   weibull = FALSE ) resCalcEn <- as.data.frame(resCalcEn) plot(Polygon1, main = resCalcEn[, \"Energy_Output_Red\"][[1]]) points(x = resCalcEn[, \"Bx\"], y = resCalcEn[, \"By\"], pch = 20)    ## Create a variable and multidirectional wind data.frame and plot the ## resulting wind rose data.in10 <- data.frame(ws = runif(10, 1, 25), wd = runif(10, 0, 360)) windrosePlot <- plot_windrose(   data = data.in10, spd = data.in10$ws,   dir = data.in10$wd, dirres = 10, spdmax = 20 )   ## Calculate the energy outputs for the first individual with more than one ## wind direction. resCalcEn <- calculate_energy(   sel = initpop[[1]], referenceHeight = 50,   RotorHeight = 50, SurfaceRoughness = 0.14, wnkl = 20,   distanz = 100000, dirSpeed = data.in10,   RotorR = 50, polygon1 = Polygon1, topograp = FALSE,   weibull = FALSE ) # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/circle_intersection.html","id":null,"dir":"Reference","previous_headings":"","what":"Get area of intersecting circles — circle_intersection","title":"Get area of intersecting circles — circle_intersection","text":"Calculate intersection area two circles different radii different heights","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/circle_intersection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get area of intersecting circles — circle_intersection","text":"","code":"circle_intersection(r1, r2, h1, h2, dx)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/circle_intersection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get area of intersecting circles — circle_intersection","text":"r1 radius circle 1 r2 radius circle 2 h1 height circle center 1 h2 height circle center 2 dx distance x-axis centers","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/circle_intersection.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get area of intersecting circles — circle_intersection","text":"numeric value","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/crossover.html","id":null,"dir":"Reference","previous_headings":"","what":"Crossover Method — crossover","title":"Crossover Method — crossover","text":"crossover method creates new offspring selected individuals permutating genetic codes.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/crossover.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Crossover Method — crossover","text":"","code":"crossover(se6, u, uplimit, crossPart = c(\"EQU\", \"RAN\"), verbose, seed)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/crossover.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Crossover Method — crossover","text":"se6 selected individuals. output selection u crossover point rate uplimit upper limit allowed permutations crossPart crossover method. Either \"EQU\" \"RAN\" verbose TRUE, print information seed Set seed comparability. Default NULL","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/crossover.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Crossover Method — crossover","text":"Returns binary coded matrix permutations grid cells, 0 indicates turbine 1 indicates turbine grid cell.","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/crossover.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Crossover Method — crossover","text":"","code":"## Create two random parents with an index and random binary values Parents <- data.frame(   ID = 1:20,   bin = sample(c(0, 1), 20, replace = TRUE, prob = c(70, 30)),   bin.1 = sample(c(0, 1), 20, replace = TRUE, prob = c(30, 70)) )  ## Create random Fitness values for both individuals FitParents <- data.frame(ID = 1, Fitness = 1000, Fitness.1 = 20)  ## Assign both values to a list CrossSampl <- list(Parents, FitParents) ## Cross their data at equal locations with 2 crossover parts crossover(CrossSampl, u = 1.1, uplimit = 300, crossPart = \"EQU\") #>       [,1] [,2] [,3] [,4] #>  [1,]    1    1    0    0 #>  [2,]    1    1    0    0 #>  [3,]    1    1    0    0 #>  [4,]    1    1    0    0 #>  [5,]    1    1    0    0 #>  [6,]    0    0    1    1 #>  [7,]    0    0    1    1 #>  [8,]    1    1    0    0 #>  [9,]    1    1    0    0 #> [10,]    0    0    0    0 #> [11,]    0    0    0    0 #> [12,]    0    0    0    0 #> [13,]    1    0    1    0 #> [14,]    1    1    1    1 #> [15,]    1    0    1    0 #> [16,]    0    0    0    0 #> [17,]    0    1    0    1 #> [18,]    0    1    0    1 #> [19,]    1    1    1    1 #> [20,]    1    0    1    0  ## with 3 crossover parts and equal locations crossover(CrossSampl, u = 2.5, uplimit = 300, crossPart = \"EQU\") #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #>  [1,]    1    1    1    1    0    0    0    0 #>  [2,]    1    1    1    1    0    0    0    0 #>  [3,]    1    1    1    1    0    0    0    0 #>  [4,]    1    1    1    1    0    0    0    0 #>  [5,]    1    1    1    1    0    0    0    0 #>  [6,]    0    0    0    0    1    1    1    1 #>  [7,]    0    0    0    0    1    1    1    1 #>  [8,]    1    1    0    0    1    1    0    0 #>  [9,]    1    1    0    0    1    1    0    0 #> [10,]    0    0    0    0    0    0    0    0 #> [11,]    0    0    0    0    0    0    0    0 #> [12,]    0    0    0    0    0    0    0    0 #> [13,]    1    1    0    0    1    1    0    0 #> [14,]    1    1    1    1    1    1    1    1 #> [15,]    1    0    1    0    1    0    1    0 #> [16,]    0    0    0    0    0    0    0    0 #> [17,]    0    1    0    1    0    1    0    1 #> [18,]    0    1    0    1    0    1    0    1 #> [19,]    1    1    1    1    1    1    1    1 #> [20,]    1    0    1    0    1    0    1    0  ## or with random locations and 5 crossover parts crossover(CrossSampl, u = 4.9, uplimit = 300, crossPart = \"RAN\") #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #>  [1,]    1    1    1    1    1    1    1    1    1     1     1     1     1 #>  [2,]    1    1    1    1    1    1    1    1    1     1     1     1     1 #>  [3,]    1    1    1    1    1    1    1    1    1     1     1     1     1 #>  [4,]    1    1    1    1    1    1    1    1    1     1     1     1     1 #>  [5,]    1    1    1    1    1    1    1    1    1     1     1     1     1 #>  [6,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #>  [7,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #>  [8,]    1    1    1    1    1    1    1    1    1     1     1     1     1 #>  [9,]    1    1    1    1    1    1    1    1    0     0     0     0     0 #> [10,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [11,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [12,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [13,]    1    1    1    1    1    1    1    1    0     0     0     0     0 #> [14,]    1    1    1    1    1    1    1    1    1     1     1     1     1 #> [15,]    1    1    1    1    0    0    0    0    1     1     1     1     0 #> [16,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [17,]    0    0    1    1    0    0    1    1    0     0     1     1     0 #> [18,]    0    1    0    1    0    1    0    1    0     1     0     1     0 #> [19,]    1    1    1    1    1    1    1    1    1     1     1     1     1 #> [20,]    1    0    1    0    1    0    1    0    1     0     1     0     1 #>       [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] #>  [1,]     1     1     1     0     0     0     0     0     0     0     0     0 #>  [2,]     1     1     1     0     0     0     0     0     0     0     0     0 #>  [3,]     1     1     1     0     0     0     0     0     0     0     0     0 #>  [4,]     1     1     1     0     0     0     0     0     0     0     0     0 #>  [5,]     1     1     1     0     0     0     0     0     0     0     0     0 #>  [6,]     0     0     0     1     1     1     1     1     1     1     1     1 #>  [7,]     0     0     0     1     1     1     1     1     1     1     1     1 #>  [8,]     1     1     1     0     0     0     0     0     0     0     0     0 #>  [9,]     0     0     0     1     1     1     1     1     1     1     1     0 #> [10,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [11,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [12,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [13,]     0     0     0     1     1     1     1     1     1     1     1     0 #> [14,]     1     1     1     1     1     1     1     1     1     1     1     1 #> [15,]     0     0     0     1     1     1     1     0     0     0     0     1 #> [16,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [17,]     0     1     1     0     0     1     1     0     0     1     1     0 #> [18,]     1     0     1     0     1     0     1     0     1     0     1     0 #> [19,]     1     1     1     1     1     1     1     1     1     1     1     1 #> [20,]     0     1     0     1     0     1     0     1     0     1     0     1 #>       [,26] [,27] [,28] [,29] [,30] [,31] [,32] #>  [1,]     0     0     0     0     0     0     0 #>  [2,]     0     0     0     0     0     0     0 #>  [3,]     0     0     0     0     0     0     0 #>  [4,]     0     0     0     0     0     0     0 #>  [5,]     0     0     0     0     0     0     0 #>  [6,]     1     1     1     1     1     1     1 #>  [7,]     1     1     1     1     1     1     1 #>  [8,]     0     0     0     0     0     0     0 #>  [9,]     0     0     0     0     0     0     0 #> [10,]     0     0     0     0     0     0     0 #> [11,]     0     0     0     0     0     0     0 #> [12,]     0     0     0     0     0     0     0 #> [13,]     0     0     0     0     0     0     0 #> [14,]     1     1     1     1     1     1     1 #> [15,]     1     1     1     0     0     0     0 #> [16,]     0     0     0     0     0     0     0 #> [17,]     0     1     1     0     0     1     1 #> [18,]     1     0     1     0     1     0     1 #> [19,]     1     1     1     1     1     1     1 #> [20,]     0     1     0     1     0     1     0"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/fitness.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate the Individual Fitness values — fitness","title":"Evaluate the Individual Fitness values — fitness","text":"fitness individuals current population calculated energy output evaluated calculate_energy. function reduces resulting energy outputs single fitness value individual.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/fitness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate the Individual Fitness values — fitness","text":"","code":"fitness(   selection,   referenceHeight,   RotorHeight,   SurfaceRoughness,   Polygon,   resol1,   rot,   dirspeed,   srtm_crop,   topograp,   cclRaster,   weibull,   Parallel,   numCluster )"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/fitness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate the Individual Fitness values — fitness","text":"selection list containing individuals current population. referenceHeight height incoming wind speeds measured. Default RotorHeight RotorHeight height turbine hub SurfaceRoughness surface roughness length meters. terrain effect model, surface roughness calculated every grid cell using elevation land cover data. Default 0.3 Polygon considered area shapefile. resol1 resolution grid meter. rot desired rotor radius meter. dirspeed wind data list. srtm_crop list 3 raster, 1) elevation, 2) orographic 3) terrain raster. Calculated genetic_algorithm topograp Boolean value, indicates terrain effect model enabled . Default FALSE cclRaster Corine Land Cover raster, adapted previously hand surface roughness length every land cover type. used, terrain effect model activated. weibull raster representing estimated wind speeds Parallel boolean value, indicating whether parallel processing used. parallel doParallel packages used parallel processing. Default FALSE numCluster Parallel TRUE, variable defines number clusters used. Default 2","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/fitness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate the Individual Fitness values — fitness","text":"Returns list every individual, consisting X & Y coordinates, rotor radii, runs selected grid cell IDs, resulting energy outputs, efficiency rates fitness values.","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/fitness.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate the Individual Fitness values — fitness","text":"","code":"# \\donttest{ ## Create a random rectangular shapefile library(sf) Polygon1 <- sf::st_as_sf(sf::st_sfc(   sf::st_polygon(list(cbind(     c(4498482, 4498482, 4499991, 4499991, 4498482),     c(2668272, 2669343, 2669343, 2668272, 2668272)   ))),   crs = 3035 ))  ## Create a uniform and unidirectional wind data.frame and plots the ## resulting wind rose ## Uniform wind speed and single wind direction wind <- data.frame(ws = 12, wd = 0) # windrosePlot <- plot_windrose(data = wind, spd = wind$ws, #                dir = wind$wd, dirres=10, spdmax=20)  ## Calculate a Grid and an indexed data.frame with coordinates and ## grid cell IDs. Grid1 <- grid_area(shape = Polygon1, size = 200, prop = 1) Grid <- Grid1[[1]] AmountGrids <- nrow(Grid)  wind <- list(wind, probab = 100) startsel <- init_population(Grid, 10, 20) fit <- fitness(   selection = startsel, referenceHeight = 100, RotorHeight = 100,   SurfaceRoughness = 0.3, Polygon = Polygon1, resol1 = 200, rot = 20,   dirspeed = wind, srtm_crop = \"\", topograp = FALSE, cclRaster = \"\",   Parallel = FALSE ) # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/genetic_algorithm.html","id":null,"dir":"Reference","previous_headings":"","what":"Run a Genetic Algorithm to optimize a wind farm layout — genetic_algorithm","title":"Run a Genetic Algorithm to optimize a wind farm layout — genetic_algorithm","text":"Run Genetic Algorithm optimize layout wind turbines given area. algorithm works fixed amount turbines, fixed rotor radius mean wind speed value every incoming wind direction.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/genetic_algorithm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run a Genetic Algorithm to optimize a wind farm layout — genetic_algorithm","text":"","code":"genetic_algorithm(   Polygon1,   GridMethod,   Rotor,   n,   fcrR,   referenceHeight,   RotorHeight,   SurfaceRoughness,   Proportionality,   iteration,   mutr,   vdirspe,   topograp,   elitism,   nelit,   selstate,   crossPart1,   trimForce,   Projection,   sourceCCL,   sourceCCLRoughness,   weibull,   weibullsrc,   Parallel,   numCluster,   verbose = FALSE,   plotit = FALSE )"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/genetic_algorithm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run a Genetic Algorithm to optimize a wind farm layout — genetic_algorithm","text":"Polygon1 considered area SpatialPolygon, SimpleFeature Polygon coordinates matrix/data.frame GridMethod polygon divided rectangular hexagonal grid cells? default Rectangular grid. Hexagonal grids computed assigning h hexagon input variable. Rotor rotor radius meter n amount turbines fcrR numeric value used grid spacing. Default 5 referenceHeight height incoming wind speeds measured. Default RotorHeight RotorHeight height turbine hub SurfaceRoughness surface roughness length meters. terrain effect model, surface roughness calculated every grid cell using elevation land cover data. Default 0.3 Proportionality numeric value used grid calculation, determines percentage grid cell must overlay area. Default 1 iteration number iterations. Default 20 mutr numeric mutation rate. Default 0.008 vdirspe data.frame containing wind speeds, directions probabilities. See windata_format. topograp Boolean value, indicates terrain effect model enabled . Default FALSE elitism Boolean value, indicates whether elitism activated . Default TRUE nelit elitism TRUE, input determines amount individuals elite group. Default 7 selstate Determines selection method used, \"FIX\" selects constant percentage \"VAR\" selects variable percentage, depending development fitness values. Default \"FIX\" crossPart1 Determines crossover method used, \"EQU\" divides genetic code equal intervals \"RAN\" divides genetic code random locations. Default \"EQU\" trimForce TRUE algorithm use probabilistic approach correct windfarms desired amount turbines. FALSE adjustment random. Default FALSE Projection spatial reference system. Depending PROJ-version, either numeric EPSG-code Proj4-string. Default EPSG:3035 sourceCCL path Corine Land Cover raster (.tif). required terrain effect model activated. sourceCCLRoughness source adapted Corine Land Cover legend .csv file. required terrain effect model activated. default .csv file within package (~/extdata) taken already adapted manually. weibull boolean value specifies whether take Weibull parameters account. TRUE, wind speed values vdirspe ignored. algorithm calculate mean wind speed every wind turbine according Weibull parameters. Default FALSE weibullsrc list Weibull parameter rasters, first list item must shape parameter raster k second item must scale parameter raster Weibull distribution. list given, rasters included package used instead, currently cover Austria. variable used weibull = TRUE. Parallel boolean value, indicating whether parallel processing used. parallel doParallel packages used parallel processing. Default FALSE numCluster Parallel TRUE, variable defines number clusters used. Default 2 verbose TRUE print information every generation. Default FALSE plotit TRUE plot best windfarm every generation. Default FALSE","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/genetic_algorithm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run a Genetic Algorithm to optimize a wind farm layout — genetic_algorithm","text":"result matrix aggregated values per generation; best individual regarding energy efficiency per generation, fuzzy control variables per generation, list fitness values per generation, amount individuals process, matrix energy, efficiency fitness values per generation, selection crossover parameters, matrix generational difference maximum mean energy output, matrix given inputs, dataframe wind information, mutation rate per generation matrix tested wind farm layouts.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/genetic_algorithm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run a Genetic Algorithm to optimize a wind farm layout — genetic_algorithm","text":"terrain effect model can included optimization process. Therefore, digital elevation model downloaded automatically via elevatr::get_elev_raster function. land cover raster can also downloaded automatically EEA-website, path raster file can passed sourceCCL. algorithm uses adapted version Raster legend (\"clc_legend.csv\"), stored package directory ~/inst/extdata. use values land cover roughness lengths, insert column named \"Rauhigkeit_z\" .csv file, assign surface roughness length land cover types. sure rows filled numeric values save file \";\" separation. Assign path file input variable sourceCCLRoughness function.","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/genetic_algorithm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run a Genetic Algorithm to optimize a wind farm layout — genetic_algorithm","text":"","code":"if (FALSE) { # \\dontrun{ ## Create a random rectangular shapefile library(sf)  Polygon1 <- sf::st_as_sf(sf::st_sfc(   sf::st_polygon(list(cbind(     c(4498482, 4498482, 4499991, 4499991, 4498482),     c(2668272, 2669343, 2669343, 2668272, 2668272)   ))),   crs = 3035 ))  ## Create a uniform and unidirectional wind data.frame and plot the ## resulting wind rose data.in <- data.frame(ws = 12, wd = 0) windrosePlot <- plot_windrose(   data = data.in, spd = data.in$ws,   dir = data.in$wd, dirres = 10, spdmax = 20 )  ## Runs an optimization run for 20 iterations with the ## given shapefile (Polygon1), the wind data.frame (data.in), ## 12 turbines (n) with rotor radii of 30m (Rotor) and rotor height of 100m. result <- genetic_algorithm(   Polygon1 = Polygon1,   n = 12,   vdirspe = data.in,   Rotor = 30,   RotorHeight = 100 ) plot_windfarmGA(result = result, Polygon1 = Polygon1) } # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/get_dist_angles.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate distances and angles of possibly influencing turbines — get_dist_angles","title":"Calculate distances and angles of possibly influencing turbines — get_dist_angles","text":"Calculate distances angles turbine potentially influencing turbines.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/get_dist_angles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate distances and angles of possibly influencing turbines — get_dist_angles","text":"","code":"get_dist_angles(t, o, wnkl, dist, polYgon, plotAngles = FALSE)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/get_dist_angles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate distances and angles of possibly influencing turbines — get_dist_angles","text":"t data.frame current individual X Y coordinates o numeric value indicating index current turbine wnkl angle wake influences considered negligible dist numeric value indicating distance, wake effects considered eliminated. polYgon shapefile representing considered area plotAngles logical variable, used plot distances angles. Default FALSE","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/get_dist_angles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate distances and angles of possibly influencing turbines — get_dist_angles","text":"Returns matrix distances, angles heights potentially influencing turbines","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/get_dist_angles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate distances and angles of possibly influencing turbines — get_dist_angles","text":"","code":"library(sf)  ## Exemplary input Polygon with 2km x 2km: Polygon1 <- sf::st_as_sf(sf::st_sfc(   sf::st_polygon(list(cbind(     c(4498482, 4498482, 4499991, 4499991, 4498482),     c(2668272, 2669343, 2669343, 2668272, 2668272)   ))),   crs = 3035 ))  ## Create a random windfarm with 10 turbines t <- st_coordinates(st_sample(Polygon1, 10)) t <- cbind(t, \"Z\" = 1) wnkl <- 20 dist <- 100000  ## Evaluate and plot for every turbine all other potentially influencing turbines potInfTur <- list() for (i in 1:(length(t[, 1]))) {   potInfTur[[i]] <- get_dist_angles(     t = t, o = i, wnkl = wnkl,     dist = dist, polYgon = Polygon1, plotAngles = TRUE   ) }           potInfTur #> [[1]] #>      Ax Ay      Bx      By Cx Cy Laenge_C Laenge_B Laenge_A alpha betha gamma #> [1,]  0  0 4499324 2669115  0  0        0        0        0     0     0     0 #>      height1 height2 #> [1,]       0       0 #>  #> [[2]] #>           Ax      Ay      Bx      By      Cx      Cy Laenge_C Laenge_B Laenge_A #> [1,] 4499324 2669115 4499223 2668495 4499324 2668495 627.6793    619.5      101 #> [2,] 4499281 2669089 4499223 2668495 4499281 2668495 596.3273    593.5       58 #>         alpha    betha gamma height1 height2 #> [1,] 9.265732 80.73427    90       1       1 #> [2,] 5.588172 84.41183    90       1       1 #>  #> [[3]] #>           Ax      Ay      Bx      By      Cx      Cy Laenge_C Laenge_B Laenge_A #> [1,] 4499870 2669079 4499891 2668958 4499870 2668958 123.1414   121.25     21.5 #>        alpha   betha gamma height1 height2 #> [1,] 10.0502 79.9498    90       1       1 #>  #> [[4]] #>      Ax Ay      Bx      By Cx Cy Laenge_C Laenge_B Laenge_A alpha betha gamma #> [1,]  0  0 4498788 2669304  0  0        0        0        0     0     0     0 #>      height1 height2 #> [1,]       0       0 #>  #> [[5]] #>      Ax Ay      Bx      By Cx Cy Laenge_C Laenge_B Laenge_A alpha betha gamma #> [1,]  0  0 4499281 2669089  0  0        0        0        0     0     0     0 #>      height1 height2 #> [1,]       0       0 #>  #> [[6]] #>      Ax Ay      Bx      By Cx Cy Laenge_C Laenge_B Laenge_A alpha betha gamma #> [1,]  0  0 4499870 2669079  0  0        0        0        0     0     0     0 #>      height1 height2 #> [1,]       0       0 #>  #> [[7]] #>      Ax Ay      Bx      By Cx Cy Laenge_C Laenge_B Laenge_A alpha betha gamma #> [1,]  0  0 4499474 2668859  0  0        0        0        0     0     0     0 #>      height1 height2 #> [1,]       0       0 #>  #> [[8]] #>           Ax      Ay      Bx      By      Cx      Cy Laenge_C Laenge_B Laenge_A #> [1,] 4498788 2669304 4498836 2668846 4498788 2668846 460.7052   458.25     47.5 #>         alpha    betha gamma height1 height2 #> [1,] 5.925308 84.07469    90       1       1 #>  #> [[9]] #>           Ax      Ay      Bx      By      Cx      Cy Laenge_C Laenge_B Laenge_A #> [1,] 4499324 2669115 4499316 2668523 4499324 2668523 592.5684    592.5        9 #> [2,] 4499281 2669089 4499316 2668523 4499281 2668523 567.5194    566.5       34 #>          alpha    betha gamma height1 height2 #> [1,] 0.8385004 89.16150    90       1       1 #> [2,] 3.4649097 86.53509    90       1       1 #>  #> [[10]] #>           Ax      Ay      Bx      By      Cx      Cy Laenge_C Laenge_B Laenge_A #> [1,] 4499870 2669079 4499853 2668944 4499870 2668944 136.5623    135.5       17 #>        alpha    betha gamma height1 height2 #> [1,] 7.15317 82.84683    90       1       1 #>"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/get_grids.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the Grid-IDs from binary matrix — get_grids","title":"Get the Grid-IDs from binary matrix — get_grids","text":"Retrieve grid ID's binary matrix, binary code indicates grid cells used current wind farm constellation.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/get_grids.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the Grid-IDs from binary matrix — get_grids","text":"","code":"get_grids(trimtonOut, Grid)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/get_grids.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the Grid-IDs from binary matrix — get_grids","text":"trimtonOut Input matrix binary values Grid Grid considered area","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/get_grids.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the Grid-IDs from binary matrix — get_grids","text":"Returns list individuals X Y coordinates grid cell ID.","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/get_grids.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the Grid-IDs from binary matrix — get_grids","text":"","code":"# \\donttest{ ## Create a random rectangular shapefile library(sf) Polygon1 <- sf::st_as_sf(sf::st_sfc(   sf::st_polygon(list(cbind(     c(0, 0, 2000, 2000, 0),     c(0, 2000, 2000, 0, 0)   ))),   crs = 3035 ))  ## Calculate a Grid and an indexed data.frame with coordinates and ## grid cell Ids. Grid1 <- grid_area(shape = Polygon1, size = 200, prop = 1) Grid <- Grid1[[1]] AmountGrids <- nrow(Grid)  startsel <- init_population(Grid, 10, 20) wind <- data.frame(ws = 12, wd = 0) wind <- list(wind, probab = 100) fit <- fitness(   selection = startsel, referenceHeight = 100, RotorHeight = 100,   SurfaceRoughness = 0.3, Polygon = Polygon1, resol1 = 200, rot = 20,   dirspeed = wind, srtm_crop = \"\", topograp = FALSE, cclRaster = \"\" ) allparks <- do.call(\"rbind\", fit)  ## SELECTION ## print the amount of Individuals selected. ## Check if the amount of Turbines is as requested. selec6best <- selection(fit, Grid, 2, TRUE, 6, \"VAR\")  ## CROSSOVER ## u determines the amount of crossover points, ## crossPart determines the method used (Equal/Random), ## uplimit is the maximum allowed permutations crossOut <- crossover(selec6best, 2, uplimit = 300, crossPart = \"RAN\")  ## MUTATION ## Variable Mutation Rate is activated if more than 2 individuals represent ## the current best solution. mut <- mutation(a = crossOut, p = 0.3)  ## TRIMTON ## After Crossover and Mutation, the amount of turbines in a windpark change ## and have to be corrected to the required amount of turbines. mut1 <- trimton(   mut = mut, nturb = 10, allparks = allparks,   nGrids = AmountGrids, trimForce = FALSE )  ## Get the new Grid-Ids and run a new fitness run. getRectV <- get_grids(mut1, Grid) fit <- fitness(   selection = getRectV, referenceHeight = 100, RotorHeight = 100,   SurfaceRoughness = 0.3, Polygon = Polygon1, resol1 = 200, rot = 20,   dirspeed = wind, srtm_crop = \"\", topograp = FALSE, cclRaster = \"\" ) head(fit) #> $`14,17,25,31,43,52,54,82,91,95` #>          X    Y EfficAllDir EnergyOverall AbschGesamt Run RotorR Rect_ID #>  [1,]  700  300    95.95216      7567.792         100   1     20      14 #>  [2,] 1300  300    95.95216      7567.792           0   1     20      17 #>  [3,]  900  500    95.95216      7567.792         100   1     20      25 #>  [4,]  100  700    95.95216      7567.792         100   1     20      31 #>  [5,]  500  900    95.95216      7567.792           0   1     20      43 #>  [6,]  300 1100    95.95216      7567.792         100   1     20      52 #>  [7,]  700 1100    95.95216      7567.792           0   1     20      54 #>  [8,]  300 1700    95.95216      7567.792           0   1     20      82 #>  [9,]  100 1900    95.95216      7567.792           0   1     20      91 #> [10,]  900 1900    95.95216      7567.792           0   1     20      95 #>       Parkfitness #>  [1,]    7567.792 #>  [2,]    7567.792 #>  [3,]    7567.792 #>  [4,]    7567.792 #>  [5,]    7567.792 #>  [6,]    7567.792 #>  [7,]    7567.792 #>  [8,]    7567.792 #>  [9,]    7567.792 #> [10,]    7567.792 #>  #> $`31,39,49,52,59,61,83,86,89,99` #>          X    Y EfficAllDir EnergyOverall AbschGesamt Run RotorR Rect_ID #>  [1,]  100  700    80.20216      6325.582         100   2     20      31 #>  [2,] 1700  700    80.20216      6325.582         400   2     20      39 #>  [3,] 1700  900    80.20216      6325.582         300   2     20      49 #>  [4,]  300 1100    80.20216      6325.582           0   2     20      52 #>  [5,] 1700 1100    80.20216      6325.582         200   2     20      59 #>  [6,]  100 1300    80.20216      6325.582           0   2     20      61 #>  [7,]  500 1700    80.20216      6325.582           0   2     20      83 #>  [8,] 1100 1700    80.20216      6325.582           0   2     20      86 #>  [9,] 1700 1700    80.20216      6325.582         100   2     20      89 #> [10,] 1700 1900    80.20216      6325.582           0   2     20      99 #>       Parkfitness #>  [1,]    6325.582 #>  [2,]    6325.582 #>  [3,]    6325.582 #>  [4,]    6325.582 #>  [5,]    6325.582 #>  [6,]    6325.582 #>  [7,]    6325.582 #>  [8,]    6325.582 #>  [9,]    6325.582 #> [10,]    6325.582 #>  #> $`4,27,30,33,61,65,69,87,93,94` #>          X    Y EfficAllDir EnergyOverall AbschGesamt Run RotorR Rect_ID #>  [1,]  700  100    98.40852      7761.526         100   3     20       4 #>  [2,] 1300  500    98.40852      7761.526         100   3     20      27 #>  [3,] 1900  500    98.40852      7761.526           0   3     20      30 #>  [4,]  500  700    98.40852      7761.526         100   3     20      33 #>  [5,]  100 1300    98.40852      7761.526           0   3     20      61 #>  [6,]  900 1300    98.40852      7761.526           0   3     20      65 #>  [7,] 1700 1300    98.40852      7761.526           0   3     20      69 #>  [8,] 1300 1700    98.40852      7761.526           0   3     20      87 #>  [9,]  500 1900    98.40852      7761.526           0   3     20      93 #> [10,]  700 1900    98.40852      7761.526           0   3     20      94 #>       Parkfitness #>  [1,]    7761.526 #>  [2,]    7761.526 #>  [3,]    7761.526 #>  [4,]    7761.526 #>  [5,]    7761.526 #>  [6,]    7761.526 #>  [7,]    7761.526 #>  [8,]    7761.526 #>  [9,]    7761.526 #> [10,]    7761.526 #>  #> $`2,3,9,55,56,57,63,65,80,89` #>          X    Y EfficAllDir EnergyOverall AbschGesamt Run RotorR Rect_ID #>  [1,]  300  100    93.83756      7401.013           0   4     20       2 #>  [2,]  500  100    93.83756      7401.013         100   4     20       3 #>  [3,] 1700  100    93.83756      7401.013         100   4     20       9 #>  [4,]  900 1100    93.83756      7401.013         100   4     20      55 #>  [5,] 1100 1100    93.83756      7401.013           0   4     20      56 #>  [6,] 1300 1100    93.83756      7401.013           0   4     20      57 #>  [7,]  500 1300    93.83756      7401.013           0   4     20      63 #>  [8,]  900 1300    93.83756      7401.013           0   4     20      65 #>  [9,] 1900 1500    93.83756      7401.013           0   4     20      80 #> [10,] 1700 1700    93.83756      7401.013           0   4     20      89 #>       Parkfitness #>  [1,]    7401.013 #>  [2,]    7401.013 #>  [3,]    7401.013 #>  [4,]    7401.013 #>  [5,]    7401.013 #>  [6,]    7401.013 #>  [7,]    7401.013 #>  [8,]    7401.013 #>  [9,]    7401.013 #> [10,]    7401.013 #>  #> $`12,38,48,53,54,62,68,76,91,94` #>          X    Y EfficAllDir EnergyOverall AbschGesamt Run RotorR Rect_ID #>  [1,]  300  300    89.86455       7087.66         100   5     20      12 #>  [2,] 1500  700    89.86455       7087.66         200   5     20      38 #>  [3,] 1500  900    89.86455       7087.66         100   5     20      48 #>  [4,]  500 1100    89.86455       7087.66           0   5     20      53 #>  [5,]  700 1100    89.86455       7087.66         100   5     20      54 #>  [6,]  300 1300    89.86455       7087.66           0   5     20      62 #>  [7,] 1500 1300    89.86455       7087.66           0   5     20      68 #>  [8,] 1100 1500    89.86455       7087.66           0   5     20      76 #>  [9,]  100 1900    89.86455       7087.66           0   5     20      91 #> [10,]  700 1900    89.86455       7087.66           0   5     20      94 #>       Parkfitness #>  [1,]     7087.66 #>  [2,]     7087.66 #>  [3,]     7087.66 #>  [4,]     7087.66 #>  [5,]     7087.66 #>  [6,]     7087.66 #>  [7,]     7087.66 #>  [8,]     7087.66 #>  [9,]     7087.66 #> [10,]     7087.66 #>  #> $`15,19,23,45,47,66,71,88,94,100` #>          X    Y EfficAllDir EnergyOverall AbschGesamt Run RotorR Rect_ID #>  [1,]  900  300    98.25615      7749.509         100   6     20      15 #>  [2,] 1700  300    98.25615      7749.509           0   6     20      19 #>  [3,]  500  500    98.25615      7749.509           0   6     20      23 #>  [4,]  900  900    98.25615      7749.509           0   6     20      45 #>  [5,] 1300  900    98.25615      7749.509           0   6     20      47 #>  [6,] 1100 1300    98.25615      7749.509           0   6     20      66 #>  [7,]  100 1500    98.25615      7749.509           0   6     20      71 #>  [8,] 1500 1700    98.25615      7749.509           0   6     20      88 #>  [9,]  700 1900    98.25615      7749.509           0   6     20      94 #> [10,] 1900 1900    98.25615      7749.509           0   6     20     100 #>       Parkfitness #>  [1,]    7749.509 #>  [2,]    7749.509 #>  [3,]    7749.509 #>  [4,]    7749.509 #>  [5,]    7749.509 #>  [6,]    7749.509 #>  [7,]    7749.509 #>  [8,]    7749.509 #>  [9,]    7749.509 #> [10,]    7749.509 #>  # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/grid_area.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a grid from a Simple Feature Polygon — grid_area","title":"Make a grid from a Simple Feature Polygon — grid_area","text":"Create grid given polygon certain resolution proportionality. grid cell centroids represent possible wind turbine locations.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/grid_area.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a grid from a Simple Feature Polygon — grid_area","text":"","code":"grid_area(shape, size = 500, prop = 1, plotGrid = FALSE)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/grid_area.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a grid from a Simple Feature Polygon — grid_area","text":"shape Simple Feature Polygon considered area size cellsize grid meters. Default 500 prop factor used grid calculation. determines minimum percentage grid cell must cover area. Default 1 plotGrid Logical value indicating whether results plotted. Default FALSE","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/grid_area.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a grid from a Simple Feature Polygon — grid_area","text":"Returns list 2 elements. List element 1 grid cell IDS, X Y coordinates centers grid cell. List element 2 grid Simple Feature Polygons, used plotting purposes.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/grid_area.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Make a grid from a Simple Feature Polygon — grid_area","text":"grid genetic algorithm resolution Rotor   * fcrR. See arguments genetic_algorithm","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/grid_area.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make a grid from a Simple Feature Polygon — grid_area","text":"","code":"# \\donttest{ ## Exemplary input Polygon with 2km x 2km: library(sf) Polygon1 <- sf::st_as_sf(sf::st_sfc(   sf::st_polygon(list(cbind(     c(0, 0, 2000, 2000, 0),     c(0, 2000, 2000, 0, 0)   ))),   crs = 3035 ))  ## Create a Grid grid_area(Polygon1, 200, 1, TRUE)   grid_area(Polygon1, 400, 1, TRUE)    ## Examplary irregular input Polygon Polygon1 <- sf::st_as_sf(sf::st_sfc(   sf::st_polygon(list(cbind(     c(0, 0, 2000, 3000, 0),     c(20, 200, 2000, 0, 20)   ))),   crs = 3035 ))  ## Create a Grid grid_area(Polygon1, 200, 1, TRUE)   grid_area(Polygon1, 200, 0.1, TRUE)   grid_area(Polygon1, 400, 1, TRUE)   grid_area(Polygon1, 400, 0.1, TRUE)   # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/hexa_area.html","id":null,"dir":"Reference","previous_headings":"","what":"Polygon to Hexagonal Grids — hexa_area","title":"Polygon to Hexagonal Grids — hexa_area","text":"function takes Simple Feature Polygon size argument creates list indexed matrix coordinates Simple Feature object, consists hexagonal grids.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/hexa_area.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Polygon to Hexagonal Grids — hexa_area","text":"","code":"hexa_area(shape, size = 500, plotGrid = FALSE)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/hexa_area.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Polygon to Hexagonal Grids — hexa_area","text":"shape Simple Feature Polygon considered area size cellsize grid meters. Default 500 plotGrid Logical value indicating whether results plotted. Default FALSE","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/hexa_area.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Polygon to Hexagonal Grids — hexa_area","text":"Returns list 2 elements. List element 1 grid cell IDS, X Y coordinates centers grid cell. List element 2 grid Simple Feature Polygons, used plotting purposes.","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/hexa_area.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Polygon to Hexagonal Grids — hexa_area","text":"","code":"library(sf) ## Exemplary input Polygon with 2km x 2km: Poly <- sf::st_as_sf(sf::st_sfc(   sf::st_polygon(list(cbind(     c(4498482, 4498482, 4499991, 4499991, 4498482),     c(2668272, 2669343, 2669343, 2668272, 2668272)   ))),   crs = 3035 )) HexGrid <- hexa_area(Poly, 100, TRUE)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/hole_shape.html","id":null,"dir":"Reference","previous_headings":"","what":"A POLYGON with a hole — hole_shape","title":"A POLYGON with a hole — hole_shape","text":"POLYGON hole","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/hole_shape.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A POLYGON with a hole — hole_shape","text":"","code":"hole_shape"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/hole_shape.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A POLYGON with a hole — hole_shape","text":"object class sf (inherits data.frame) 1 rows 2 columns.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/init_population.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a random initial Population — init_population","title":"Create a random initial Population — init_population","text":"Create nStart random sub-selections indexed grid assign binary variable 1 selected grids. function initiates genetic algorithm first random population needed first iteration.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/init_population.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a random initial Population — init_population","text":"","code":"init_population(Grid, n, nStart = 100)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/init_population.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a random initial Population — init_population","text":"Grid data.frame output grid_area\" function, X Y coordinates Grid cell IDs. n numeric value indicating amount required turbines. nStart numeric indicating amount randomly generated initial individuals. Default 100.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/init_population.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a random initial Population — init_population","text":"Returns list nStart initial individuals, consisting n turbines. Resulting list x y coordinates, grid cell ID binary variable 1, indicating turbine grid cell.","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/init_population.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a random initial Population — init_population","text":"","code":"library(sf) ## Exemplary input Polygon with 2km x 2km: Polygon1 <- sf::st_as_sf(sf::st_sfc(   sf::st_polygon(list(cbind(     c(4498482, 4498482, 4499991, 4499991, 4498482),     c(2668272, 2669343, 2669343, 2668272, 2668272)   ))),   crs = 3035 ))  Grid <- grid_area(Polygon1, 200, 1, TRUE)    ## Create 5 individuals with 10 wind turbines each. firstPop <- init_population(Grid = Grid[[1]], n = 10, nStart = 5)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/isSpatial.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform to Simple Feature Polygons — isSpatial","title":"Transform to Simple Feature Polygons — isSpatial","text":"Helper Function, transforms SpatialPolygons coordinates matrix/data.frame - form Simple Feature Polygon","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/isSpatial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform to Simple Feature Polygons — isSpatial","text":"","code":"isSpatial(shape, proj)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/isSpatial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform to Simple Feature Polygons — isSpatial","text":"shape area SpatialPolygon, SimpleFeature Polygon coordinates matrix/data.frame proj Projection assigned matrix / data.frame coordinates","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/isSpatial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform to Simple Feature Polygons — isSpatial","text":"Simple Feature Polygon","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/isSpatial.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transform to Simple Feature Polygons — isSpatial","text":"columns named, look common abbreviation match x/y long/lat columns. columns named, first 2 numeric columns taken.","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/isSpatial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform to Simple Feature Polygons — isSpatial","text":"","code":"# \\donttest{ library(sf) df <- rbind(   c(4498482, 2668272), c(4498482, 2669343),   c(4499991, 2669343), c(4499991, 2668272) ) isSpatial(df) #> Geometry set for 1 feature  #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 4498482 ymin: 2668272 xmax: 4499991 ymax: 2669343 #> CRS:           NA #> POLYGON ((4498482 2668272, 4498482 2669343, 449...  Polygon1 <- sf::st_as_sf(sf::st_sfc(   sf::st_polygon(list(cbind(     c(4498482, 4498482, 4499991, 4499991, 4498482),     c(2668272, 2669343, 2669343, 2668272, 2668272)   ))),   crs = 3035 )) isSpatial(st_coordinates(Polygon1), 3035) #> Geometry set for 1 feature  #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 4498482 ymin: 2668272 xmax: 4499991 ymax: 2669343 #> Projected CRS: ETRS89-extended / LAEA Europe #> POLYGON ((4498482 2668272, 4498482 2669343, 449... # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/multi_shape.html","id":null,"dir":"Reference","previous_headings":"","what":"A MULTIPOLYGON with 3 Polygons — multi_shape","title":"A MULTIPOLYGON with 3 Polygons — multi_shape","text":"MULTIPOLYGON 3 Polygons","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/multi_shape.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A MULTIPOLYGON with 3 Polygons — multi_shape","text":"","code":"multi_shape"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/multi_shape.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A MULTIPOLYGON with 3 Polygons — multi_shape","text":"object class sf (inherits data.frame) 1 rows 1 columns.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/mutation.html","id":null,"dir":"Reference","previous_headings":"","what":"Mutation Method — mutation","title":"Mutation Method — mutation","text":"function randomly mutates individual's genetic code","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/mutation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mutation Method — mutation","text":"","code":"mutation(a, p, seed = NULL)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/mutation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mutation Method — mutation","text":"binary matrix individuals p mutation rate seed Set seed comparability. Default NULL","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/mutation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mutation Method — mutation","text":"Returns binary matrix mutated genes.","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/mutation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mutation Method — mutation","text":"","code":"## Create 4 random individuals with binary values a <- cbind(   bin0 = sample(c(0, 1), 20, replace = TRUE, prob = c(70, 30)),   bin1 = sample(c(0, 1), 20, replace = TRUE, prob = c(30, 70)),   bin2 = sample(c(0, 1), 20, replace = TRUE, prob = c(30, 70)),   bin3 = sample(c(0, 1), 20, replace = TRUE, prob = c(30, 70)) ) a #>       bin0 bin1 bin2 bin3 #>  [1,]    0    1    1    0 #>  [2,]    0    1    0    1 #>  [3,]    1    1    0    1 #>  [4,]    1    1    1    1 #>  [5,]    1    1    1    1 #>  [6,]    0    1    0    1 #>  [7,]    1    0    1    1 #>  [8,]    0    0    1    1 #>  [9,]    0    0    0    0 #> [10,]    0    1    1    1 #> [11,]    0    1    1    1 #> [12,]    0    1    0    0 #> [13,]    0    1    0    1 #> [14,]    0    1    1    0 #> [15,]    0    1    1    1 #> [16,]    0    0    1    1 #> [17,]    0    1    1    1 #> [18,]    0    1    0    1 #> [19,]    0    1    1    1 #> [20,]    0    1    0    1  ## Mutate the individuals with a low percentage aMut <- mutation(a, 0.1, NULL) ## Check which values are not like the originals a == aMut #>        bin0  bin1 bin2 bin3 #>  [1,]  TRUE  TRUE TRUE TRUE #>  [2,]  TRUE  TRUE TRUE TRUE #>  [3,]  TRUE  TRUE TRUE TRUE #>  [4,]  TRUE  TRUE TRUE TRUE #>  [5,] FALSE  TRUE TRUE TRUE #>  [6,]  TRUE  TRUE TRUE TRUE #>  [7,]  TRUE  TRUE TRUE TRUE #>  [8,]  TRUE  TRUE TRUE TRUE #>  [9,]  TRUE FALSE TRUE TRUE #> [10,] FALSE  TRUE TRUE TRUE #> [11,]  TRUE  TRUE TRUE TRUE #> [12,]  TRUE  TRUE TRUE TRUE #> [13,]  TRUE  TRUE TRUE TRUE #> [14,]  TRUE  TRUE TRUE TRUE #> [15,]  TRUE  TRUE TRUE TRUE #> [16,]  TRUE FALSE TRUE TRUE #> [17,]  TRUE  TRUE TRUE TRUE #> [18,]  TRUE  TRUE TRUE TRUE #> [19,]  TRUE FALSE TRUE TRUE #> [20,]  TRUE  TRUE TRUE TRUE  ## Mutate the individuals with a high percentage aMut <- mutation(a, 0.4, NULL) ## Check which values are not like the originals a == aMut #>        bin0  bin1  bin2  bin3 #>  [1,]  TRUE  TRUE  TRUE FALSE #>  [2,] FALSE FALSE FALSE  TRUE #>  [3,]  TRUE FALSE FALSE  TRUE #>  [4,] FALSE FALSE  TRUE  TRUE #>  [5,]  TRUE FALSE FALSE FALSE #>  [6,]  TRUE FALSE  TRUE  TRUE #>  [7,]  TRUE FALSE FALSE FALSE #>  [8,] FALSE  TRUE FALSE FALSE #>  [9,] FALSE  TRUE FALSE  TRUE #> [10,] FALSE  TRUE  TRUE  TRUE #> [11,]  TRUE  TRUE FALSE FALSE #> [12,] FALSE  TRUE FALSE FALSE #> [13,]  TRUE FALSE FALSE FALSE #> [14,] FALSE  TRUE  TRUE  TRUE #> [15,]  TRUE FALSE  TRUE FALSE #> [16,] FALSE FALSE FALSE  TRUE #> [17,] FALSE  TRUE  TRUE  TRUE #> [18,]  TRUE FALSE  TRUE FALSE #> [19,]  TRUE FALSE  TRUE FALSE #> [20,]  TRUE  TRUE  TRUE  TRUE"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/package_installed.html","id":null,"dir":"Reference","previous_headings":"","what":"Is the package installed or not — package_installed","title":"Is the package installed or not — package_installed","text":"package installed ","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/package_installed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is the package installed or not — package_installed","text":"","code":"is_foreach_installed()  is_parallel_installed()  is_doparallel_installed()  is_ggplot2_installed()  is_leaflet_installed()  is_elevatr_installed()"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/package_installed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is the package installed or not — package_installed","text":"invisible boolean value, indicating package installed .","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/permutations.html","id":null,"dir":"Reference","previous_headings":"","what":"Enumerate the Combinations or Permutations of the Elements of a Vector — permutations","title":"Enumerate the Combinations or Permutations of the Elements of a Vector — permutations","text":"permutations enumerates possible permutations. function forked minified gtools::permutations","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/permutations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enumerate the Combinations or Permutations of the Elements of a Vector — permutations","text":"","code":"permutations(n, r, v = 1:n)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/permutations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enumerate the Combinations or Permutations of the Elements of a Vector — permutations","text":"n Size source vector r Size target vectors v Source vector. Defaults 1:n","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/permutations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Enumerate the Combinations or Permutations of the Elements of a Vector — permutations","text":"Returns matrix row contains vector length r.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/permutations.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Enumerate the Combinations or Permutations of the Elements of a Vector — permutations","text":"Venables, Bill. \"Programmers Note\", R-News, Vol 1/1, Jan. 2001. https://cran.r-project.org/doc/Rnews/","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/permutations.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Enumerate the Combinations or Permutations of the Elements of a Vector — permutations","text":"Original versions Bill Venables. Extended handle repeats.allowed Gregory R. Warnes","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_cloud.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot outputs of all generations with standard deviations — plot_cloud","title":"Plot outputs of all generations with standard deviations — plot_cloud","text":"Plot fitness, efficiency energy outputs generations corresponding standard deviations.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_cloud.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot outputs of all generations with standard deviations — plot_cloud","text":"","code":"plot_cloud(result, pl = FALSE)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_cloud.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot outputs of all generations with standard deviations — plot_cloud","text":"result output genetic_algorithm pl results plotted? Default FALSE","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_cloud.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot outputs of all generations with standard deviations — plot_cloud","text":"Returns data.frame values fitness, efficiency energy evaluated individuals","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_cloud.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot outputs of all generations with standard deviations — plot_cloud","text":"","code":"# \\donttest{ ## Plot the results of a hexagonal grid optimization plcdf <- plot_cloud(resulthex, TRUE)  # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_development.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the progress of populations — plot_development","title":"Plot the progress of populations — plot_development","text":"Plot changes mean max fitness values previous generation.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_development.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the progress of populations — plot_development","text":"","code":"plot_development(result)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_development.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the progress of populations — plot_development","text":"result output genetic_algorithm","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_development.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the progress of populations — plot_development","text":"Returns NULL. Used plotting","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_development.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the progress of populations — plot_development","text":"","code":"# \\donttest{ plot_development(resultrect)  #> NULL # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_evolution.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the evolution of fitness values — plot_evolution","title":"Plot the evolution of fitness values — plot_evolution","text":"Plot evolution energy outputs efficiency rates whole generations. Plots min, mean max values.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_evolution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the evolution of fitness values — plot_evolution","text":"","code":"plot_evolution(result, ask = TRUE, spar = 0.1)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_evolution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the evolution of fitness values — plot_evolution","text":"result output genetic_algorithm ask R wait interaction subsequent plotting. Default TRUE spar numeric value determining exact spline drawn. Default 0.1","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_evolution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the evolution of fitness values — plot_evolution","text":"Returns NULL. Used plotting","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_evolution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the evolution of fitness values — plot_evolution","text":"","code":"# \\donttest{ ## Plot the results of a rectangular grid optimization plot_evolution(resultrect, ask = TRUE, spar = 0.1)   #> NULL # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_fitness_evolution.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the changes of min/mean/max fitness values — plot_fitness_evolution","title":"Plot the changes of min/mean/max fitness values — plot_fitness_evolution","text":"Plot evolution fitness values change min, mean max fitness values former generations.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_fitness_evolution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the changes of min/mean/max fitness values — plot_fitness_evolution","text":"","code":"plot_fitness_evolution(result, spar = 0.1)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_fitness_evolution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the changes of min/mean/max fitness values — plot_fitness_evolution","text":"result output genetic_algorithm spar numeric value determining exact spline drawn. Default 0.1","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_fitness_evolution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the changes of min/mean/max fitness values — plot_fitness_evolution","text":"Returns NULL. Used plotting","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_fitness_evolution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the changes of min/mean/max fitness values — plot_fitness_evolution","text":"","code":"# \\donttest{ ## Plot the results of a hexagonal grid optimization plot_fitness_evolution(resulthex, 0.1)  #> NULL # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_leaflet.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a wind warm with leaflet — plot_leaflet","title":"Plot a wind warm with leaflet — plot_leaflet","text":"Plot resulting wind farm leaflet map.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_leaflet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a wind warm with leaflet — plot_leaflet","text":"","code":"plot_leaflet(result, Polygon1, which = 1, orderitems = TRUE, GridPol)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_leaflet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a wind warm with leaflet — plot_leaflet","text":"result output genetic_algorithm Polygon1 considered area SpatialPolygon, SimpleFeature Polygon coordinates matrix/data.frame numeric value, indicating individual plot. default 1. Combined orderitems = TRUE show best performing wind farm. orderitems logical value indicating whether results ordered energy values TRUE chronologically FALSE GridPol default, grid calculated based inputs result Polygon1. another spatial object output  grid_area hexa_area functions can also ","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_leaflet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a wind warm with leaflet — plot_leaflet","text":"Returns leaflet map.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_leaflet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a wind warm with leaflet — plot_leaflet","text":"","code":"if (FALSE) { # \\dontrun{ ## Plot the best wind farm on a leaflet map (ordered by energy values) plot_leaflet(result = resulthex, Polygon1 = sp_polygon, which = 1)  ## Plot the last wind farm (ordered by chronology). plot_leaflet(   result = resulthex, Polygon1 = sp_polygon, orderitems = FALSE,   which = 1 )  ## Plot the best wind farm on a leaflet map with the rectangular Grid Grid <- grid_area(sp_polygon, size = 150, prop = 0.4) plot_leaflet(   result = resultrect, Polygon1 = sp_polygon, which = 1,   GridPol = Grid[[2]] )  ## Plot the last wind farm with hexagonal Grid Grid <- hexa_area(sp_polygon, size = 75) plot_leaflet(   result = resulthex, Polygon1 = sp_polygon, which = 1,   GridPol = Grid[[2]] ) } # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_parkfitness.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the genetic algorithm results — plot_parkfitness","title":"Plot the genetic algorithm results — plot_parkfitness","text":"Plot evolution fitness values influences selection, crossover mutation.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_parkfitness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the genetic algorithm results — plot_parkfitness","text":"","code":"plot_parkfitness(result, spar = 0.1)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_parkfitness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the genetic algorithm results — plot_parkfitness","text":"result output genetic_algorithm spar numeric value determining exact spline drawn. Default 0.1","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_parkfitness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the genetic algorithm results — plot_parkfitness","text":"Returns NULL. Used plotting","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_parkfitness.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the genetic algorithm results — plot_parkfitness","text":"","code":"# \\donttest{ ## Plot the results of a hexagonal grid optimization plot_parkfitness(resulthex)      #> NULL # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_random_search.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the result of a randomized output. — plot_random_search","title":"Plot the result of a randomized output. — plot_random_search","text":"Plotting method results random_search_single random_search.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_random_search.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the result of a randomized output. — plot_random_search","text":"","code":"plot_random_search(resultRS, result, Polygon1, best)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_random_search.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the result of a randomized output. — plot_random_search","text":"resultRS result random functions random_search_single random_search. result output genetic_algorithm Polygon1 considered area SpatialPolygon, SimpleFeature Polygon coordinates matrix/data.frame best many best candidates plot. Default 1.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_random_search.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the result of a randomized output. — plot_random_search","text":"Returns NULL. Used plotting","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_random_search.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the result of a randomized output. — plot_random_search","text":"","code":"# \\donttest{ library(sf) Polygon1 <- sf::st_as_sf(sf::st_sfc(   sf::st_polygon(list(cbind(     c(4498482, 4498482, 4499991, 4499991, 4498482),     c(2668272, 2669343, 2669343, 2668272, 2668272)   ))),   crs = 3035 ))  Res <- random_search(result = resultrect, Polygon1 = Polygon1) plot_random_search(resultRS = Res, result = resultrect, Polygon1 = Polygon1, best = 2)     # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the best results — plot_result","title":"Plot the best results — plot_result","text":"Plot best solutions genetic algorithm. Depending plotEn, either best energy efficiency solutions can plotted. best indicates amount best solutions plot.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the best results — plot_result","text":"","code":"plot_result(   result,   Polygon1,   best = 3,   plotEn = 1,   topographie = FALSE,   Grid = TRUE,   sourceCCLRoughness = NULL,   sourceCCL = NULL,   weibullsrc )"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the best results — plot_result","text":"result output genetic_algorithm Polygon1 considered area SpatialPolygon, SimpleFeature Polygon coordinates matrix/data.frame best numeric value indicating many best individuals plotted plotEn numeric value indicates best energy efficiency output plotted. 1 plots best energy solutions 2 plots best efficiency solutions topographie logical value, indicating whether terrain effects considered plotted Grid TRUE (default) used grid added plot. can also pass another Simple Feature object sourceCCLRoughness source adapted Corine Land Cover legend .csv file. required terrain effect model activated. default .csv file within package (~/extdata) taken already adapted manually. sourceCCL path Corine Land Cover raster (.tif). required terrain effect model activated. weibullsrc list Weibull parameter rasters, first list item must shape parameter raster k second item must scale parameter raster Weibull distribution. list given, rasters included package used instead, currently cover Austria. variable used weibull = TRUE.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the best results — plot_result","text":"Returns data.frame best (energy/efficiency) individual iterations","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the best results — plot_result","text":"","code":"if (FALSE) { # \\dontrun{ ## Add some data examples from the package library(sf) Polygon1 <- sf::st_as_sf(sf::st_sfc(   sf::st_polygon(list(cbind(     c(4498482, 4498482, 4499991, 4499991, 4498482),     c(2668272, 2669343, 2669343, 2668272, 2668272)   ))),   crs = 3035 ))  ## Plot the results of a hexagonal grid optimization plot_result(resulthex, Polygon1, best = 1, plotEn = 1, topographie = FALSE)  ## Plot the results of a rectangular grid optimization plot_result(resultrect, Polygon1, best = 1, plotEn = 1, topographie = FALSE) } # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_viewshed.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot visibility — plot_viewshed","title":"Plot visibility — plot_viewshed","text":"Calculate plot visibility given points given area.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_viewshed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot visibility — plot_viewshed","text":"","code":"plot_viewshed(r, turbine_locs, h1 = 0, h2 = 0, plot = TRUE, ...)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_viewshed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot visibility — plot_viewshed","text":"r elevation SpatRaster turbine_locs Coordinates, SpatialPoint SimpleFeature Points representing wind turbines h1 single number numeric vector giving extra height offsets turbine_locs h2 height offset Point 2 plot result plotted. Default TRUE ... forwarded terra::plot","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_viewshed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot visibility — plot_viewshed","text":"mosaiced SpatRaster, representing visibility turbine_locs","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_viewshed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot visibility — plot_viewshed","text":"","code":"# \\donttest{ library(sf) library(terra) #> terra 1.8.10  f <- system.file(\"ex/elev.tif\", package = \"terra\") r <- rast(f) x <- project(r, \"EPSG:2169\") shape <- sf::st_as_sf(as.polygons(terra::boundaries(x))) plot(shape)  st_crs(shape) <- 2169 locs <- st_sample(shape, 10, type = \"random\") plot_viewshed(x, locs, h1 = 0, h2 = 0, plot = TRUE)  #> class       : SpatRaster  #> dimensions  : 108, 75, 1  (nrow, ncol, nlyr) #> resolution  : 771.9715, 771.9715  (x, y) #> extent      : 49072.34, 106970.2, 56572.15, 139945.1  (xmin, xmax, ymin, ymax) #> coord. ref. : LUREF / Luxembourg TM (EPSG:2169)  #> source(s)   : memory #> varname     : spat_1fe4bfb8608_8164_2_o8up7yuDdJ6XHBX  #> name        : viewshed  #> min value   :        0  #> max value   :        1  # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_windfarmGA.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the results of an optimization run — plot_windfarmGA","title":"Plot the results of an optimization run — plot_windfarmGA","text":"Plot results genetic algorithm run given inputs. Several plots try show relevant effects outcomes algorithm. 6 plot methods available can selected individually.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_windfarmGA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the results of an optimization run — plot_windfarmGA","text":"","code":"plot_windfarmGA(   result,   Polygon1,   whichPl = \"all\",   best = 1,   plotEn = 1,   weibullsrc )"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_windfarmGA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the results of an optimization run — plot_windfarmGA","text":"result output genetic_algorithm Polygon1 considered area SpatialPolygon, SimpleFeature Polygon coordinates matrix/data.frame whichPl plots shown: 1-6 possible. default \"\" shows available plots best numeric value indicating many best individuals plotted plotEn numeric value indicates best energy efficiency output plotted. 1 plots best energy solutions 2 plots best efficiency solutions weibullsrc list Weibull parameter rasters, first list item must shape parameter raster k second item must scale parameter raster Weibull distribution. list given, rasters included package used instead, currently cover Austria. variable used weibull = TRUE.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_windfarmGA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the results of an optimization run — plot_windfarmGA","text":"Returns NULL. Used plotting","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_windfarmGA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the results of an optimization run — plot_windfarmGA","text":"","code":"if (FALSE) { # \\dontrun{ library(sf) Polygon1 <- sf::st_as_sf(sf::st_sfc(   sf::st_polygon(list(cbind(     c(4498482, 4498482, 4499991, 4499991, 4498482),     c(2668272, 2669343, 2669343, 2668272, 2668272)   ))),   crs = 3035 ))  ## Plot the results of a hexagonal grid optimization plot_windfarmGA(resulthex, Polygon1, whichPl = \"all\", best = 1, plotEn = 1)  ## Plot the results of a rectangular grid optimization plot_windfarmGA(resultrect, Polygon1, whichPl = \"all\", best = 1, plotEn = 1) } # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_windrose.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a Windrose — plot_windrose","title":"Plot a Windrose — plot_windrose","text":"Plot wind rose wind data frame.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_windrose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a Windrose — plot_windrose","text":"","code":"plot_windrose(   data,   spd,   dir,   spdres = 2,   dirres = 10,   spdmin = 1,   spdmax = 30,   palette = \"YlGnBu\",   spdseq = NULL,   plotit = TRUE )"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_windrose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a Windrose — plot_windrose","text":"data data.frame containing wind information spd column wind speeds \"data\" dir column wind directions \"data\" spdres increment wind speed legend. Default 2 dirres size wind sectors. Default 10 spdmin Minimum wind speed. Default 1 spdmax Maximal wind speed. Default 30 palette color palette used drawing wind rose spdseq wind speed sequence, used plotting plotit windrose plotted? Default TRUE","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_windrose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a Windrose — plot_windrose","text":"Returns NULL. Used plotting","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/plot_windrose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a Windrose — plot_windrose","text":"","code":"## Exemplary Input Wind speed and direction data frame # Uniform wind speed and single wind direction data.in <- data.frame(ws = 12, wd = 0) windrosePlot <- plot_windrose(   data = data.in, spd = data.in$ws,   dir = data.in$wd )   # Random wind speeds and random wind directions data.in <- data.frame(   ws = sample(1:25, 10),   wd = sample(1:260, 10) ) windrosePlot <- plot_windrose(   data = data.in, spd = data.in$ws,   dir = data.in$wd )"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/random_search.html","id":null,"dir":"Reference","previous_headings":"","what":"Randomize the output of the Genetic Algorithm — random_search","title":"Randomize the output of the Genetic Algorithm — random_search","text":"Perform random search grid cells, optimize output wind farm layout.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/random_search.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Randomize the output of the Genetic Algorithm — random_search","text":"","code":"random_search(result, Polygon1, n = 20, best = 1, Plot = FALSE, max_dist = 2.2)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/random_search.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Randomize the output of the Genetic Algorithm — random_search","text":"result resulting matrix function genetic_algorithm Polygon1 considered area SpatialPolygon, SimpleFeature Polygon coordinates matrix/data.frame n number random searches performed. Default 20. best best individuals starting conditions random search. default 1. Plot random search plotted? Default FALSE max_dist numeric value multiplied rotor radius perform collision checks. Default 2.2","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/random_search.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Randomize the output of the Genetic Algorithm — random_search","text":"Returns list.","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/random_search.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Randomize the output of the Genetic Algorithm — random_search","text":"","code":"# \\donttest{ new <- random_search(resultrect, sp_polygon, n = 20, best = 4) plot_random_search(resultRS = new, result = resultrect, Polygon1 = sp_polygon, best = 2)     # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/random_search_single.html","id":null,"dir":"Reference","previous_headings":"","what":"Randomize the location of a single turbine — random_search_single","title":"Randomize the location of a single turbine — random_search_single","text":"Perform random search single turbine, optimize output wind farm layout.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/random_search_single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Randomize the location of a single turbine — random_search_single","text":"","code":"random_search_single(result, Polygon1, n = 20, Plot = FALSE, max_dist = 2.2)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/random_search_single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Randomize the location of a single turbine — random_search_single","text":"result resulting matrix function genetic_algorithm Polygon1 considered area SpatialPolygon, SimpleFeature Polygon coordinates matrix/data.frame n number random searches performed. Default 20. Plot random search plotted? Default FALSE max_dist numeric value multiplied rotor radius perform collision checks. Default 2.2","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/random_search_single.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Randomize the location of a single turbine — random_search_single","text":"Returns list","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/readinteger.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Input Crossover Method — readinteger","title":"Check Input Crossover Method — readinteger","text":"Checks whether input crossover given correctly. , message prompted asks input one 2 available crossover methods. available inputs \"E\" \"R\". \"E\" refers partitioning equal intervals \"R\" refers random partitioning.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/readinteger.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Input Crossover Method — readinteger","text":"","code":"readinteger()"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/readinteger.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Input Crossover Method — readinteger","text":"Returns selected crossover method (character)","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/readintegerSel.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Input Selection Method — readintegerSel","title":"Check Input Selection Method — readintegerSel","text":"Checks whether input selection given correctly. , message prompted asks input one 2 available selection methods. available inputs \"F\" \"V\". \"F\" refers fixed percentage 50% \"V\" refers variable percentage, based development population fitness values.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/readintegerSel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Input Selection Method — readintegerSel","text":"","code":"readintegerSel()"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/readintegerSel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Input Selection Method — readintegerSel","text":"Returns selected selection method (character)","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/resulthex.html","id":null,"dir":"Reference","previous_headings":"","what":"A resulting matrix of genetic_algorithm with 10 iterations and a hexagonal grid derived from sp_polygon — resulthex","title":"A resulting matrix of genetic_algorithm with 10 iterations and a hexagonal grid derived from sp_polygon — resulthex","text":"resulting matrix genetic_algorithm 10 iterations hexagonal grid derived sp_polygon","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/resulthex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A resulting matrix of genetic_algorithm with 10 iterations and a hexagonal grid derived from sp_polygon — resulthex","text":"","code":"resulthex"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/resulthex.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A resulting matrix of genetic_algorithm with 10 iterations and a hexagonal grid derived from sp_polygon — resulthex","text":"object class matrix (inherits array) 10 rows 13 columns.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/resultrect.html","id":null,"dir":"Reference","previous_headings":"","what":"A resulting matrix of genetic_algorithm with 200 iterations and a rectangular grid derived from sp_polygon — resultrect","title":"A resulting matrix of genetic_algorithm with 200 iterations and a rectangular grid derived from sp_polygon — resultrect","text":"resulting matrix genetic_algorithm 200 iterations rectangular grid derived sp_polygon","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/resultrect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A resulting matrix of genetic_algorithm with 200 iterations and a rectangular grid derived from sp_polygon — resultrect","text":"","code":"resultrect"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/resultrect.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A resulting matrix of genetic_algorithm with 200 iterations and a rectangular grid derived from sp_polygon — resultrect","text":"object class matrix (inherits array) 200 rows 13 columns.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/selection.html","id":null,"dir":"Reference","previous_headings":"","what":"Selection Method — selection","title":"Selection Method — selection","text":"Select certain amount individuals recombine parental teams. Add mean fitness value parents parental team. Depending selected selstate, algorithm either take always 50 percent variable percentage current population. variable percentage depends evolution populations fitness values.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/selection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Selection Method — selection","text":"","code":"selection(fit, Grid, teil, elitism, nelit, selstate, verbose)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/selection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Selection Method — selection","text":"fit list fitness-evaluated individuals Grid indexed grid output grid_area teil numeric value determines selection percentage elitism Boolean value, indicates whether elitism activated . Default TRUE nelit elitism TRUE, input determines amount individuals elite group. Default 7 selstate Determines selection method used, \"FIX\" selects constant percentage \"VAR\" selects variable percentage, depending development fitness values. Default \"FIX\" verbose TRUE, print information.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/selection.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Selection Method — selection","text":"Returns list 2 elements. Element 1 binary encoded matrix shows selected individuals. Element 2 represent mean fitness values parental team.","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/selection.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Selection Method — selection","text":"","code":"# \\donttest{ ## Exemplary input Polygon with 2km x 2km: library(sf) Polygon1 <- sf::st_as_sf(sf::st_sfc(   sf::st_polygon(list(cbind(     c(4498482, 4498482, 4499991, 4499991, 4498482),     c(2668272, 2669343, 2669343, 2668272, 2668272)   ))),   crs = 3035 ))  ## Calculate a Grid and an indexed data.frame with coordinates and grid cell Ids. Grid1 <- grid_area(shape = Polygon1, size = 200, prop = 1) Grid <- Grid1[[1]] AmountGrids <- nrow(Grid)  startsel <- init_population(Grid, 10, 20) wind <- as.data.frame(cbind(ws = 12, wd = 0)) wind <- list(wind, probab = 100) fit <- fitness(   selection = startsel, referenceHeight = 100, RotorHeight = 100,   SurfaceRoughness = 0.3, Polygon = Polygon1, resol1 = 200,   rot = 20, dirspeed = wind,   srtm_crop = \"\", topograp = FALSE, cclRaster = \"\" ) allparks <- do.call(\"rbind\", fit) ## SELECTION ## print the amount of Individuals selected. Check if the amount ## of Turbines is as requested. selec6best <- selection(fit, Grid, 2, TRUE, 6, \"VAR\") selec6best <- selection(fit, Grid, 2, TRUE, 6, \"FIX\") selec6best <- selection(fit, Grid, 4, FALSE, 6, \"FIX\") # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/sp_polygon.html","id":null,"dir":"Reference","previous_headings":"","what":"The rectangular POLYGON used to create resultrect & resulthex — sp_polygon","title":"The rectangular POLYGON used to create resultrect & resulthex — sp_polygon","text":"rectangular POLYGON used create resultrect & resulthex","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/sp_polygon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The rectangular POLYGON used to create resultrect & resulthex — sp_polygon","text":"","code":"sp_polygon"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/sp_polygon.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"The rectangular POLYGON used to create resultrect & resulthex — sp_polygon","text":"object class sf (inherits data.frame) 1 rows 1 columns.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/splitAt.html","id":null,"dir":"Reference","previous_headings":"","what":"Split matrices or numeric vectors at specific indices — splitAt","title":"Split matrices or numeric vectors at specific indices — splitAt","text":"function used crossover method split genetic code certain intervals. See also crossover.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/splitAt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split matrices or numeric vectors at specific indices — splitAt","text":"","code":"splitAt(x, pos)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/splitAt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split matrices or numeric vectors at specific indices — splitAt","text":"x numeric variable represents individual's binary genetic code pos numeric value indicates split genetic code","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/splitAt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split matrices or numeric vectors at specific indices — splitAt","text":"Returns list split genetic code.","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/splitAt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Split matrices or numeric vectors at specific indices — splitAt","text":"","code":"splitAt(1:100, 20) #> [[1]] #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 #>  #> [[2]] #>  [1]  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38 #> [20]  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57 #> [39]  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76 #> [58]  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95 #> [77]  96  97  98  99 100 #>  splitAt(as.matrix(1:100), 20) #> [[1]] #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 #>  #> [[2]] #>  [1]  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38 #> [20]  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57 #> [39]  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76 #> [58]  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95 #> [77]  96  97  98  99 100 #>"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/terrain_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Get topographic rasters — terrain_model","title":"Get topographic rasters — terrain_model","text":"Calculate SpatRasters needed terrain model.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/terrain_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get topographic rasters — terrain_model","text":"","code":"terrain_model(   topograp = TRUE,   Polygon1,   sourceCCL,   sourceCCLRoughness,   plotit = FALSE,   verbose = FALSE )"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/terrain_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get topographic rasters — terrain_model","text":"topograp Boolean value, indicates terrain effect model enabled . Default FALSE Polygon1 considered area SpatialPolygon, SimpleFeature Polygon coordinates matrix/data.frame sourceCCL path Corine Land Cover raster (.tif). required terrain effect model activated. sourceCCLRoughness source adapted Corine Land Cover legend .csv file. required terrain effect model activated. default .csv file within package (~/extdata) taken already adapted manually. plotit Plots elevation data verbose TRUE print information every generation. Default FALSE","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/terrain_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get topographic rasters — terrain_model","text":"list SpatRasters","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/terrain_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get topographic rasters — terrain_model","text":"","code":"if (FALSE) { # \\dontrun{ library(sf) Polygon1 <- sf::st_as_sf(sf::st_sfc(   sf::st_polygon(list(cbind(     c(4651704, 4651704, 4654475, 4654475, 4651704),     c(2692925, 2694746, 2694746, 2692925, 2692925)   ))),   crs = 3035 )) Polygon_wgs84 <- sf::st_transform(Polygon1, st_crs(4326)) srtm <- elevatr::get_elev_raster(locations = Polygon_wgs84, z = 11) res <- terrain_model(srtm, Polygon1) } # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/trimton.html","id":null,"dir":"Reference","previous_headings":"","what":"Adjust the amount of turbines per windfarm — trimton","title":"Adjust the amount of turbines per windfarm — trimton","text":"Adjust mutated individuals required amount turbines.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/trimton.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adjust the amount of turbines per windfarm — trimton","text":"","code":"trimton(mut, nturb, allparks, nGrids, trimForce, seed)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/trimton.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adjust the amount of turbines per windfarm — trimton","text":"mut binary matrix mutated individuals nturb numeric value indicating amount required turbines allparks data.frame consisting individuals current generation nGrids numeric value indicating total amount grid cells trimForce TRUE algorithm use probabilistic approach correct windfarms desired amount turbines. FALSE adjustment random. Default FALSE seed Set seed comparability. Default NULL","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/trimton.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adjust the amount of turbines per windfarm — trimton","text":"Returns binary matrix correct amount turbines per individual","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/trimton.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adjust the amount of turbines per windfarm — trimton","text":"","code":"# \\donttest{ ## Create a random rectangular shapefile library(sf) Polygon1 <- sf::st_as_sf(sf::st_sfc(   sf::st_polygon(list(cbind(     c(0, 0, 2000, 2000, 0),     c(0, 2000, 2000, 0, 0)   ))),   crs = 3035 ))  ## Create a uniform and unidirectional wind data.frame and plots the ## resulting wind rose ## Uniform wind speed and single wind direction data.in <- as.data.frame(cbind(ws = 12, wd = 0))  ## Calculate a Grid and an indexed data.frame with coordinates and grid cell Ids. Grid1 <- grid_area(shape = Polygon1, size = 200, prop = 1) Grid <- Grid1[[1]] AmountGrids <- nrow(Grid)  startsel <- init_population(Grid, 10, 20) wind <- as.data.frame(cbind(ws = 12, wd = 0)) wind <- list(wind, probab = 100) fit <- fitness(   selection = startsel, referenceHeight = 100, RotorHeight = 100,   SurfaceRoughness = 0.3, Polygon = Polygon1, resol1 = 200, rot = 20,   dirspeed = wind, srtm_crop = \"\", topograp = FALSE, cclRaster = \"\" ) allparks <- do.call(\"rbind\", fit) ## SELECTION ## print the amount of Individuals selected. ## Check if the amount of Turbines is as requested. selec6best <- selection(fit, Grid, 2, TRUE, 6, \"VAR\") selec6best <- selection(fit, Grid, 2, TRUE, 6, \"FIX\") selec6best <- selection(fit, Grid, 4, FALSE, 6, \"FIX\") ## CROSSOVER ## u determines the amount of crossover points, ## crossPart determines the method used (Equal/Random), ## uplimit is the maximum allowed permutations crossOut <- crossover(selec6best, 2, uplimit = 300, crossPart = \"RAN\") crossOut <- crossover(selec6best, 7, uplimit = 500, crossPart = \"RAN\") crossOut <- crossover(selec6best, 3, uplimit = 300, crossPart = \"EQU\") ## MUTATION ## Variable Mutation Rate is activated if more than 2 individuals represent ## the current best solution. mut <- mutation(a = crossOut, p = 0.3, NULL) ## TRIMTON ## After Crossover and Mutation, the amount of turbines in a windpark change and have to be ## corrected to the required amount of turbines. mut1 <- trimton(   mut = mut, nturb = 10, allparks = allparks, nGrids = AmountGrids,   trimForce = FALSE ) colSums(mut) #>  [1] 30 28 31 35 28 41 33 43 33 37 35 31 27 32 32 35 32 33 28 36 27 34 29 36 28 #> [26] 30 52 35 40 33 40 22 43 41 41 30 25 39 39 33 35 37 36 34 31 41 35 35 35 34 #> [51] 38 31 39 39 30 31 34 32 32 35 28 30 34 38 colSums(mut1) #>  [1] 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 #> [26] 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 #> [51] 10 10 10 10 10 10 10 10 10 10 10 10 10 10 # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/turbine_influences.html","id":null,"dir":"Reference","previous_headings":"","what":"Find potentially influencing turbines — turbine_influences","title":"Find potentially influencing turbines — turbine_influences","text":"Find turbines potentially influence another turbine save list.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/turbine_influences.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find potentially influencing turbines — turbine_influences","text":"","code":"turbine_influences(t, wnkl, dist, polYgon, dirct, plotAngles = FALSE)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/turbine_influences.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find potentially influencing turbines — turbine_influences","text":"t data.frame current individual X Y coordinates wnkl angle wake influences considered negligible dist numeric value indicating distance, wake effects considered eliminated. polYgon shapefile representing considered area dirct numeric value indicating current wind direction plotAngles logical variable, used plot distances angles. Default FALSE","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/turbine_influences.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find potentially influencing turbines — turbine_influences","text":"Returns list individuals current generation potentially influence turbines. List includes relevant coordinates, distances angles assigns Point ID.","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/turbine_influences.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find potentially influencing turbines — turbine_influences","text":"","code":"## Exemplary input Polygon with 2km x 2km: library(sf)  Polygon1 <- sf::st_as_sf(sf::st_sfc(   sf::st_polygon(list(cbind(     c(0, 0, 2000, 2000, 0),     c(0, 2000, 2000, 0, 0)   ))),   crs = 3035 ))  t <- st_coordinates(st_sample(Polygon1, 10)) t <- cbind(t, \"Z\" = 1) wnkl <- 20 dist <- 100000 dirct <- 0  res <- turbine_influences(t, wnkl, dist, Polygon1, dirct, plotAngles = TRUE)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/windata_format.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform Winddata — windata_format","title":"Transform Winddata — windata_format","text":"Helper Function, transforms winddata acceptable format","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/windata_format.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform Winddata — windata_format","text":"","code":"windata_format(df)"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/windata_format.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform Winddata — windata_format","text":"df wind data speeds, direction optionally probability column. assigned, calculated","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/windata_format.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform Winddata — windata_format","text":"list windspeed probabilities","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/windata_format.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform Winddata — windata_format","text":"","code":"# \\donttest{ wind_df <- data.frame(   ws = c(12, 30, 45),   wd = c(0, 90, 150),   probab = 30:32 ) windata_format(wind_df) #> [[1]] #>   ws  wd   probab #> 1 12   0 32.25806 #> 2 30  90 33.33333 #> 3 45 150 34.40860 #>  #> [[2]] #> [1] 32.25806 33.33333 34.40860 #>   wind_df <- data.frame(   speed = c(12, 30, 45),   direction = c(90, 90, 150),   probab = c(10, 20, 60) ) windata_format(wind_df) #> [[1]] #>   ws  wd   probab #> 1 24  90 21.73964 #> 3 45 150 78.26036 #>  #> [[2]] #> [1] 21.73964 78.26036 #>   wind_df <- data.frame(   speed = c(12, 30, 45),   direction = c(400, 90, 150) ) windata_format(wind_df) #> [[1]] #>   ws  wd   probab #> 2 30  90 33.33333 #> 3 45 150 33.33333 #> 1 12  40 33.33333 #>  #> [[2]] #> [1] 33.33333 33.33333 33.33333 #>  # }"},{"path":"https://YsoSirius.github.io/windfarmGA/reference/windfarmGA-package.html","id":null,"dir":"Reference","previous_headings":"","what":"windfarmGA: Genetic Algorithm for Wind Farm Layout Optimization — windfarmGA-package","title":"windfarmGA: Genetic Algorithm for Wind Farm Layout Optimization — windfarmGA-package","text":"genetic algorithm designed optimize wind farms shape. requires predefined amount turbines, unified rotor radius average wind speed value incoming wind direction. terrain effect model can included downloads 'SRTM' elevation model loads Corine Land Cover raster approximate surface roughness.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/reference/windfarmGA-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"windfarmGA: Genetic Algorithm for Wind Farm Layout Optimization — windfarmGA-package","text":"package optimize small wind farms irregular shapes using genetic algorithm. requires fixed amount turbines, fixed rotor radius average wind speed value incoming wind direction. terrain effect model can included downloads digital elevation model Corine Land Cover raster approximate surface roughness. information can found description function genetic_algorithm.","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/reference/windfarmGA-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"windfarmGA: Genetic Algorithm for Wind Farm Layout Optimization — windfarmGA-package","text":"Maintainer: Sebastian Gatscha sebastian_gatscha@gmx.","code":""},{"path":[]},{"path":"https://YsoSirius.github.io/windfarmGA/news/index.html","id":"windfarmga-400","dir":"Changelog","previous_headings":"","what":"windfarmGA 4.0.0","title":"windfarmGA 4.0.0","text":"CRAN release: 2025-01-18 Depends R 4.1.0 Removed package dependencies rgdal rgeos Replaced dependency raster terra Moved dependencies foreach, parallel, doParallel, elevatr Suggests 3D-circle intersection calculation. Especially relevant terrain model activated. Fix grid_area hexa_area functions sf-1.0 s2 Removed visibility functions favor terra::viewshed Removed function windfarmGA, redundant just difficult test. Changed cat() print() calls message() Reset old par settings","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/news/index.html","id":"windfarmga-300","dir":"Changelog","previous_headings":"","what":"windfarmGA 3.0.0","title":"windfarmGA 3.0.0","text":"CRAN release: 2021-05-05 dependencies sp, spatstat removed replaced sf. spatial outputs now Simple Features. Shapefile Polygon can still passed input genetic_algorithm / windfarmGA, underlying functions now require Polygon type Simple Feature. functions grid_area & hexa_area now calculated sf::st_make_grid. new dependency elevatr added provides elevation data higher resolution compared raster::getData. Several dependencies essential algorithm moved Suggests. Bugfix calculation visibility analysis. #17 viewshed parameter h1 can now also numeric vector different height offsets. #18 grid_area argument resol changed size. arguments get_dist_angles changed match arguments turbine_influences.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/news/index.html","id":"windfarmga-230","dir":"Changelog","previous_headings":"","what":"windfarmGA 2.3.0","title":"windfarmGA 2.3.0","text":"CRAN release: 2020-10-20 Due changes PROJ 6 library handling coordinate reference systems, adjustments necessary. Attempts made ensure backward compatibility. However, warnings like following now increasingly displayed:","code":"Warning message: In showSRID(uprojargs, format = \"PROJ\", multiline = \"NO\", prefer_proj = prefer_proj) :   Discarded datum European_Terrestrial_Reference_System_1989 in CRS definition"},{"path":"https://YsoSirius.github.io/windfarmGA/news/index.html","id":"windfarmga-223","dir":"Changelog","previous_headings":"","what":"windfarmGA 2.2.3","title":"windfarmGA 2.2.3","text":"CRAN release: 2019-12-16 Fix tests R 3.4.0, class(matrix) length 2. Expose options can set options(windfarmGA.cT = 0.75):","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/news/index.html","id":"windfarmga-222","dir":"Changelog","previous_headings":"","what":"windfarmGA 2.2.2","title":"windfarmGA 2.2.2","text":"CRAN release: 2019-08-27","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/news/index.html","id":"pkgdown-2-2-2","dir":"Changelog","previous_headings":"","what":"Pkgdown","title":"windfarmGA 2.2.2","text":"pkgdown documentation site now available.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/news/index.html","id":"renaming-functions-2-2-2","dir":"Changelog","previous_headings":"","what":"Renaming Functions","title":"windfarmGA 2.2.2","text":"Almost functions renamed consistent appearance clearer meaning. old functions still exist, deprecated now. Renaming Overview","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/news/index.html","id":"bugfixes--other-changes-2-2-2","dir":"Changelog","previous_headings":"","what":"Bugfixes / Other Changes","title":"windfarmGA 2.2.2","text":"legend plot_leaflet now works correctly. general linting / spell checking / performance optimization done. Weibull Raster (Austria) now separate Github-repository, instead stored package .rda file. guess never worked except computer. Corine Land Cover .tif file also stored repository, EEA webpage restrict downloads sometimes, resulted error. plot_farm_3d function temporarily removed package. functions required user-input previously used readline now changed readLines allows read file instead. can set via options(windfarmGA.connection = file()). whole lot tests written.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/news/index.html","id":"windfarmga-221","dir":"Changelog","previous_headings":"","what":"windfarmGA 2.2.1","title":"windfarmGA 2.2.1","text":"CRAN release: 2019-02-18","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/news/index.html","id":"performance-tuning--restructuring-2-2-1","dir":"Changelog","previous_headings":"","what":"Performance Tuning / Restructuring","title":"windfarmGA 2.2.1","text":"Switch matrices instead data.frames lot restructuring performance optimization whole algorithm.","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/news/index.html","id":"viewshed-analysis-2-2-1","dir":"Changelog","previous_headings":"","what":"Viewshed Analysis","title":"windfarmGA 2.2.1","text":"cansee, viewTo, rasterprofile, viewshed, plot_viewshed, interpol_view, getISO3, getDEM","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/news/index.html","id":"other-changes-2-2-1","dir":"Changelog","previous_headings":"","what":"Other Changes","title":"windfarmGA 2.2.1","text":"function genAlgo/windfarmGA plotting functions now accept SimpleFeature Polygons coordinates table format long, lat x, y column names. terrain effect model can now activated setting topograp TRUE attempt download land cover raster European Environment Agency website. plot_farm_3d Experimental rayshader function","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/news/index.html","id":"windfarmga-121","dir":"Changelog","previous_headings":"","what":"windfarmGA 1.2.1","title":"windfarmGA 1.2.1","text":"CRAN release: 2018-03-25","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/news/index.html","id":"randomization-1-2-1","dir":"Changelog","previous_headings":"","what":"Randomization","title":"windfarmGA 1.2.1","text":"output genAlgo windfarmGA can randomized/optimized following functions: - RandomSearch - RandomSearchTurb RandomSearch used randomize turbines layout RandomSearchTurb used randomize single turbine RandomSearchPlot used plot output functions, comparing original result.","code":"load(file = system.file(\"extdata/resultrect.rda\", package = \"windfarmGA\")) load(file = system.file(\"extdata/polygon.rda\", package = \"windfarmGA\")) Res = RandomSearchTurb(result = resultrect, Polygon1 = polygon, n=10) RandomSearchPlot(resultRS = Res, result = resultrect, Polygon1 = polygon, best=2)"},{"path":"https://YsoSirius.github.io/windfarmGA/news/index.html","id":"windfarmga-12","dir":"Changelog","previous_headings":"","what":"windfarmGA 1.2","title":"windfarmGA 1.2","text":"CRAN release: 2018-03-11","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/news/index.html","id":"parallel-processing-1-2","dir":"Changelog","previous_headings":"","what":"Parallel Processing","title":"windfarmGA 1.2","text":"","code":"## Runs the same optimization, but with parallel processing and 3 cores. result_par <- genAlgo(Polygon1 = Polygon1, GridMethod =\"h\", n=12, Rotor=30,                  fcrR=5,iteration=10, vdirspe = data.in,crossPart1 = \"EQU\",                  selstate=\"FIX\",mutr=0.8, Proportionality = 1,                  SurfaceRoughness = 0.3, topograp = FALSE,                  elitism=TRUE, nelit = 7, trimForce = TRUE,                  referenceHeight = 50,RotorHeight = 100,                  Parallel = TRUE, numCluster = 3) PlotWindfarmGA(result = result_par, GridMethod = \"h\", Polygon1 = Polygon1)"},{"path":"https://YsoSirius.github.io/windfarmGA/news/index.html","id":"windfarmga-11","dir":"Changelog","previous_headings":"","what":"windfarmGA 1.1","title":"windfarmGA 1.1","text":"CRAN release: 2017-07-09","code":""},{"path":"https://YsoSirius.github.io/windfarmGA/news/index.html","id":"optimization-with-hexagonal-grid-cells-1-1","dir":"Changelog","previous_headings":"","what":"Optimization with Hexagonal Grid Cells","title":"windfarmGA 1.1","text":"","code":"result_hex <- genAlgo(Polygon1 = Polygon1, GridMethod =\"h\", n=12, Rotor=30,                   fcrR=5,iteration=10, vdirspe = data.in,crossPart1 = \"EQU\",                   selstate=\"FIX\",mutr=0.8, Proportionality = 1,                   SurfaceRoughness = 0.3, topograp = FALSE,                   elitism=TRUE, nelit = 7, trimForce = TRUE,                   referenceHeight = 50,RotorHeight = 100) PlotWindfarmGA(result = result_hex, GridMethod = \"h\", Polygon1 = Polygon1)"}]
